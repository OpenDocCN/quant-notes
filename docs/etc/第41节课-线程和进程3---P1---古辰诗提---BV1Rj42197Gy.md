# 第41节课 线程和进程3 - P1 - 古辰诗提 - BV1Rj42197Gy

欢迎大家来到从零开始量化系列课程，Python基础课的第41课，这节课呢咱们接着讲进程进程，它的在Python在这个代码里边体现出来的代码方式，其实和现成的代码很像，但是你得从根本上知道。



![](img/fd86a375816514636e24c0ceaf081637_1.png)

他们俩是有本质上的区别的，县城是可以公用一块内存空间的所有的数据，所以说他有可能就是多个线程，在共用一个变量的时候，可能会对这个变量造成污染，但是进程呢它会重新开辟一个新的内存。

两个进程之间的它的变量啊，包括一些资源，他不会去进行共用的，如果说你要实现两个进程之间数据的传递，你必须得有特殊的方法，然后来实现他们之间的这个数据的传递。



![](img/fd86a375816514636e24c0ceaf081637_3.png)

所以说这两个本质上是不一样的，但是进程它也是有进程锁的，竞争锁它其实和这个咱们县城所很像，luck等于multiprocessing lock，它同样会有两把锁，一把是互斥锁。

一把是block r递归锁。

![](img/fd86a375816514636e24c0ceaf081637_5.png)

互斥锁是什么意思，就在你执行的时候，只能有一把锁，一把锁释放一把锁，就是申请只能有一把锁，递归，咱们以前学函数的时候，递归就是返回值，那个返回的那个对象是函数本身是递归，它就允许多把锁嗯。

其实咱们建议用这个互斥锁，当然现在你去测试的话，好像也可以，就是这个代码里边放两把互斥锁，可能是由于这个就是Python不断的就是更新嗯，就是他可能也做了一些改变吧，就是总而言之。

这个锁就是为了防止公共资源的被污染，但是可能可能有很多老板就会问，你都不在一块儿，就是公共的内存空间了，你公共资源怎么会被污染了，公共资源不一定指公共的内存空间对吧，比如说我下面的这个文件。

如果说两个进程都会对于我这个文件，进行频繁的读写，那会不会有问题是吧，有一些数据会不会被覆盖掉，也就是说我这个文件里边比如有一个一，我我被一个进程给取出来了，进行了修改，变成了二。

然后另外一个进程呢又使用了这个文件，然后又取出来一个一，然后变成了零，这个时候之前的那个进程的数据放回去了，变成了二了，但是又被就是说新的进程给覆盖掉，变就变成零了，还是那句话。

你如果说想实现数据的准确。

![](img/fd86a375816514636e24c0ceaf081637_7.png)

这种公共资源的准确，你肯定得给它锁上对吧，怎么锁，还是这样，就是你可以在这个下面写上block，当然这个with lock就是代表着的是一个lock acquire。

就是这个lock acquire就是锁的申请啊。

![](img/fd86a375816514636e24c0ceaf081637_9.png)

然后还有这个lock release锁的释放。

![](img/fd86a375816514636e24c0ceaf081637_11.png)

是吧，这个都是一样的，但是在这个进程里边，这个锁咱们是需要注意的，比如说我从这with lock，我把递归锁给注释掉了啊，我从这with lock，然后好像跟咱们县城里边是一样的对吧。

这个时候我执行这个代码，这个代码也没什么，是从之前的这个代码里边粘过来的，就是执行了一个任务，一个吃饭，一个睡觉，一个睡觉，一个吃饭，然后把它drain了，然后最后print了一个end。

咱们运行起来看一看，你会发现紫禁城id啊，吃饭任务开始执行哎，然后睡觉任务也开始执行了，然后吃饭任务执行结束，然后睡觉任务执行结束，你会发现它并不是并不是，就是说就是它是单独先执行完一个。

再执行另一个的，为什么会有这样的情况呢，还是咱们之前说的，你从这使用的，其实这把锁它是一个在主进城里边，这把锁，当你紫禁城在使用的时候，其实是把这把锁给copy过去了，他两把锁不是同一把锁。

所以说他就实现不了你这种串行的方式，或者说你先执行完一个任务，再执行完一个任务，你使用锁的时候，那这个时候应该怎么办呢，你需要把这把锁就是说给他传递过去，你得让他认为这是一把锁。

所以说你从这加一个lock，就是下面这个lock就是代表的是这个lock传进来的，这个lock是吧，然后你从这儿还要把这个lock给它放进去，这个lock就是你创建的这把锁啊。



![](img/fd86a375816514636e24c0ceaf081637_13.png)

两把锁是这两把锁是一样的。

![](img/fd86a375816514636e24c0ceaf081637_15.png)

都是代表你创建的，但是这把锁是代表着你的这个参数里面，传进来的，这个时候咱们再执行一遍，你可以看一看，你会发现紫禁城id是A睡觉任务开始执行了，然后睡觉任务执行结束了啊，然后它是一种串行的方式。

这样锁才能起作用，还是你得从底层去理解，就是它不是公用的一块内存，所以说你的这个必要的变量和这个资源，你需要给它传递过去，不然它只会copy1份啊，它只会copy1份，你copy过去了。



![](img/fd86a375816514636e24c0ceaf081637_17.png)

它就不是一个东西了，是不是啊，就跟咱们上一节课。

![](img/fd86a375816514636e24c0ceaf081637_19.png)

有没有给大家给大家讲过一个案例，就是啊没有。

![](img/fd86a375816514636e24c0ceaf081637_21.png)

可以给大家再写一下这样的一个案例，同样的我再定一个task。

![](img/fd86a375816514636e24c0ceaf081637_23.png)

把这个先注释掉。

![](img/fd86a375816514636e24c0ceaf081637_25.png)

就这个案例是什么呢，就是我有一个data，比如说它是一个list，然后我在这个哎之前写过吗，这个案例没有啊，我从这我这个里边我这个task只做了个什么呢，我也不要锁啊，我把这个锁给写注释掉。



![](img/fd86a375816514636e24c0ceaf081637_27.png)

我从这里边只做什么呢。

![](img/fd86a375816514636e24c0ceaf081637_29.png)

就是data append这个一啊，然后我复制一下，第二条end1。

![](img/fd86a375816514636e24c0ceaf081637_31.png)

然后print一下这个，呃这是，print一个data吧，就直接运行完了之后我就直接print data，这是子线程啊，紫禁城做的事情，然后这个里边也不需要传参是吧，也不需要传参。

然后下面这个我给它注释掉，然后把这个P2给它注释掉，然后我在主进程里边呢，我再把这个data点P，然后后边添加A，然后B后边放C，然后最终我print一个从这儿吧，在end之前我print一个好。



![](img/fd86a375816514636e24c0ceaf081637_33.png)

咱们可以运行一下，看一下，你会发现一个是里边添加的啊，当然我这三个都是一啊一一，第二个呢是ABC，这个是主进程里边操作的，但这个是紫禁城里边操作的，从这个案例你就会知道。

他其实是把data给copy了一份，紫禁城里边，data和主进程里边data完全没有任何关系对吧，所以这一点你一定要理解它，你从本质上去理解它之后以后，如果说万一要用到多进程的操作方式。



![](img/fd86a375816514636e24c0ceaf081637_35.png)

有一些莫名其妙的bug，你就能去知道他是为什么会产生这样的bug。

![](img/fd86a375816514636e24c0ceaf081637_37.png)

好吧，这是锁啊锁锁，讲完了之后，其实进程里边的东西和这个县城里边儿东西，基本上都是一致的，它的操作方式也是一致的，但是唯一的区别就是它的这个底层的逻辑，那既然这个县城有县城池，你进程肯定得有进程池是吧。

进程池在哪呢，同样的是这个，我先写一下进程池，同样的是from，这个futures import process poor啊。



![](img/fd86a375816514636e24c0ceaf081637_39.png)

process poor就是进程池，咱们把这个之前的这个任务给它打开task，我创建一个进程池嗯，在这写吧，进程池的创建和线程池的创建都差不多，就是你用一个POR等于这个process poor。

然后后边这个叫执行者嘛，同样的max worker，比如说我写一个三，后边这个mp context，这是个什么意思啊，就是它这个参数咱们一般不会用到，就是之前跟也给大家提过。



![](img/fd86a375816514636e24c0ceaf081637_41.png)

在这个LINUX或者UNIX或者Mac os上面创建一个紫禁城，它要一个fork，用fork的方式，然后在windows上面使用这个就是这样的方式啊。



![](img/fd86a375816514636e24c0ceaf081637_43.png)

你通过这个设定呃，你可以去给他设定是用什么方式来创建，在这个Mac os上，好像是可以既用这个fork，也可以用咱们windows上的那个呃，这个怎么读啊，我也不太会读，就那样的方式，从这可以设定。

他们从这个其实本质上是有区别的，fork创建的更快，而且效率更高，但是windows上这个呢就是比它的效率低一些，而且他们的就是底层的逻辑有些区别，但是对于咱们来说，这个你不用去考虑啊，这个有INIT。

咱们就知道是在初始化的时候调用的方法，可能有好多老板会问我初始化我用调用啥呀，比如说我创建了三个进程呃，就是在进程池里边创建了三个进程，我初始化的时候我需要调用啥呀，其实一般就是你创建一个进程。

进程里边需要导入包呀什么的，可能会掉到一般是怎么来操作的，而且它都是每个进程创建的时候，它会调用对吧，每个进程创建的时候会调用，但是如果说你青城池里边只有三个进程，然后但是你有十个任务。

这个十个任务不会在每执行前都会调用，就是那个三个进程在形成之前它会被调用，一般都是包着导入，动态导入什么的，后边还有一个参数叫INITARGUS，这个一看就是给这个就是这个方法。

就是前置的这个方法给它传参的对吧，这个就能就是能看懂，基本上是是吧，所以说咱们从这啊，就是这个跟这个线程池的区别，咱们可以导入一下这个线程池啊，from啊，直接从这导入是吧，three three的。



![](img/fd86a375816514636e24c0ceaf081637_45.png)

他创建这个线程池啊，three poor啊，这个里面max works，然后它会有一个name，但是它是没有的，他会就是前面会给他，就是说这个name那个地方的那个参数给它换成了，就是用什么样的方式。

但是咱们一般不会去调用啊，一般不会去调用，同样的，咱们先创建一个这个进程池，进程池里边放了三个进程，放三个进程呢，我如何去使用这个进程时呢。



![](img/fd86a375816514636e24c0ceaf081637_47.png)

同样的就是点submit啊，里边传入的是这个function啊。

![](img/fd86a375816514636e24c0ceaf081637_49.png)

第一个task是吧，task后边是需要传入参数的。

![](img/fd86a375816514636e24c0ceaf081637_51.png)

咱们之前一直讲过，这个在这个创建单进程里边传参的时候，是用一个括号来创建的。

![](img/fd86a375816514636e24c0ceaf081637_53.png)

就是就这个一个它是传入了一个元组是吧，你会发现他这后边target他就直接啊，就是说这个ARGS他没有带星号吧，所以说你需要传入一个元组，因为ARGS它表示的就是一个元组对吧，前函数讲过。

但是在咱们这个submit里边，它传入了这个ARJS，前面是带信号的。

![](img/fd86a375816514636e24c0ceaf081637_55.png)

所以说后面的参数，你就不能用这个元组来往里传，你需要挨个的去写进去啊，这一点，如果说你以后再用别人的这个方法的时候，或者说用一些你不太了解的这样方法的时候，你可以看一下星号的，你就按顺序给传入。

没有带星号的，你就需要传入这个元组啊，呃这个task，咱们把这个lock先给删掉啊，不要with lock了。



![](img/fd86a375816514636e24c0ceaf081637_57.png)

好第一个睡觉，然后给它传入几秒钟，三秒钟，这样一个咱们启动一个这个任务，显然就是说不太合适，咱们for i in range，十二十，然后我挨个的去pro点submit，然后task同样的。

这后边加上一个STR，STR这边I然后咱们时间短1。2吧，然后一定要记得在里边POR点start啊，poor不是poor点start啊，你不用poor点start啊，然后在外边。

如果说你想等他执行完了再执行这个end。

![](img/fd86a375816514636e24c0ceaf081637_59.png)

就是主进程的这个print，and你在前面要加上POR嗯。

![](img/fd86a375816514636e24c0ceaf081637_61.png)

点shut down，Shut down，然后改成true。

![](img/fd86a375816514636e24c0ceaf081637_63.png)

就是让主进程等着紫禁城都执行完了，然后再就是说往下走，这个就是下葬跟这个县城是一样的，咱们这个时候可以执行一下，然后也会他也会输出这个紫禁城的这个，PID是吧。



![](img/fd86a375816514636e24c0ceaf081637_65.png)

好运行一下紫禁城的id啊，27280啊，就睡觉，零开始执行了，212410417088，咱们可以看一下这个17088，你看21024104，17088，27280，基本上都是用的。

不是基本上肯定是全是用的，这几个现成的这个id啊，不是这个进程的id，进程的id就是他只只创建了三个进程，然后等着排队去使用这三个进程，同样的这个你也可以加上什么呀。



![](img/fd86a375816514636e24c0ceaf081637_67.png)

就是一个down啊，当然这个你函数名不一定是down啊，不一定是当，比如说我从这print一个啊，这个里边你得接参数是吧，response p o n s e response咱们也说了。



![](img/fd86a375816514636e24c0ceaf081637_69.png)

就是它的这个类型就是from concurrent，点free choice加下划线，Base import，大写的f future f u t u r e是吧。



![](img/fd86a375816514636e24c0ceaf081637_71.png)

然后你可以给他标注一下这个类型TURE，然后你可以print一下这个response r e，response应该是response，点result啊。



![](img/fd86a375816514636e24c0ceaf081637_73.png)

就是然后你从这儿接一下，比如说我呃FU等于这个，然后我每执行完一个任务，我ADD down call back，然后我执行这个down，把我的这个就是返回值做一个，就是说呃就是做一个就是说封装。

然后给它封装成这个response，然后再再在这个下面去执行这个操作，一样是可以的是吧。

![](img/fd86a375816514636e24c0ceaf081637_75.png)

他会输出啊。

![](img/fd86a375816514636e24c0ceaf081637_77.png)

它会输出，我这个咱们就不看了啊，同样的你还可以什么呀，就是在他操作之前，比如说我有一个INIT函数啊。



![](img/fd86a375816514636e24c0ceaf081637_79.png)

我INIT函数print就是要开始执行任务了啊。

![](img/fd86a375816514636e24c0ceaf081637_81.png)

同样的咱们可以在这里边给他进行传参是吧。

![](img/fd86a375816514636e24c0ceaf081637_83.png)

传参当然这个你得在他这里边来写啊。

![](img/fd86a375816514636e24c0ceaf081637_85.png)

就是他的这个嗯这个这个等于in it，然后你如果说要进行传参的话，那我就可以给他传一个，直接传一个name吧，要开始执行这个name任务栏F这个就做演示啊，这个里面INITARGUS。

等于看看它是不是这个一个INITARGUS。

![](img/fd86a375816514636e24c0ceaf081637_87.png)

![](img/fd86a375816514636e24c0ceaf081637_88.png)

它得传一个top，是top啊，To be，这个时候我括号里边传入一个name，比如说嗯睡觉吧，哎别睡别睡觉了，还是吃饭吧，吃饭测试吧。



![](img/fd86a375816514636e24c0ceaf081637_90.png)

tuber就要加一个逗号，这个时候你再来去运行它是吧，要开始执行吃饭测试任务了啊，就是他会执行三次，你创建线程不是你创建多少个进程，它就会执行几次啊，也可以进行传参，一般都是用在导包这样的事情上啊。



![](img/fd86a375816514636e24c0ceaf081637_92.png)

因为它不是说你每个任务执行前它会执行一次。

![](img/fd86a375816514636e24c0ceaf081637_94.png)

它是在你创建了三个这个进程的时候。

![](img/fd86a375816514636e24c0ceaf081637_96.png)

之前给你去执行啊，这个就是进程池，这个就是京城池呃，就是它的有返回值，你也可以进行去接对吧。

![](img/fd86a375816514636e24c0ceaf081637_98.png)

用这样的方式接返回值是最好的，咱们一直没有讲，就是之前就是这个县城里边讲过的。

![](img/fd86a375816514636e24c0ceaf081637_100.png)

那个用复写的方式来进行传参啊，不是传这个返回值是为什么。

![](img/fd86a375816514636e24c0ceaf081637_102.png)

还是那个逻辑，因为它的底层它不在一个就是共用的内存里边，你用那种方式去进行传，就是这个返回值的传传递它是有问题的。



![](img/fd86a375816514636e24c0ceaf081637_104.png)

它是传不过来的，它是传不过来的，比如说咱们可以给大家试一下，去复习一下啊，去复习一下好给它给注释掉。

![](img/fd86a375816514636e24c0ceaf081637_106.png)

这先写一个pass吧，给上面的也请注释掉啊，待会我把这个task给他放出来啊，当我去复写一个。

![](img/fd86a375816514636e24c0ceaf081637_108.png)

他说class my process，你继承的肯定是a multiprocessing process，肯定这么来写嘛对吧，然后DEF下划线下划线INIT啊，咱们之前说了。

你不要这样的方式来传这个参数里面传入name。

![](img/fd86a375816514636e24c0ceaf081637_110.png)

还有这个time，然后先super括号点下划线下划线INIT括号，然后cf点name等于name，cf点time等于time是吧。



![](img/fd86a375816514636e24c0ceaf081637_112.png)

然后你要复习一下。

![](img/fd86a375816514636e24c0ceaf081637_114.png)

同样的复习一下那个叫run，它的run方法，因为它start就是执行这个run方法嘛，咱们这里边用CP点下划线RESRESU，LT result去接一下这个task。

然后里边把cf点name和cf点这个tom给它放进去。

![](img/fd86a375816514636e24c0ceaf081637_116.png)

传进去，然后咱们之前说过，在这个县城里边，你要复习一下这个john，就是因为等得等那个线程执行完了，才有返回值嘛，所以说在JY里边，super括号点下划线就是准直接执行。

就是这个super它的这个啊啊没有这个没有效果，直接执行它的这个方法，然后return一个返回值，就是cf点下划线rise out啊，就是这样就写好了是吧，写好了之后好，咱们在它这个下面来创建my。

就是这个P1等于my process，然后这个里边传入name就是睡觉，然后这个time就是两秒钟，然后P1点start执行完了之后，P1点JOEJOE的时候，我用了IE来接一下。

接完之后我print一个IOS，然后再print一个end，是这样的逻辑吧，and我加上一个双引号啊。



![](img/fd86a375816514636e24c0ceaf081637_118.png)

是这样的一个逻辑吧，好咱们运行一下看一下啊，他开始执行任务了，但是他报错了，他报错是什么，My process object has no attribute。

下划线result就是我的这个类里面没有这个属性。

![](img/fd86a375816514636e24c0ceaf081637_120.png)

就是下划线rise out，这是为什么呢，比如说我从这我加上一个下划线，result等于一个NN值。

![](img/fd86a375816514636e24c0ceaf081637_122.png)

好，这个时候我向右拆分一下。

![](img/fd86a375816514636e24c0ceaf081637_124.png)

有些乱是吧，这个代码是在这呢，然后咱们执行的时候。

![](img/fd86a375816514636e24c0ceaf081637_126.png)

咱们来看一下紫禁城，它是开始执行了。

![](img/fd86a375816514636e24c0ceaf081637_128.png)

然后执行完了之后呢，它的返回值是NUNCH，按说它的返回值不应该用。

![](img/fd86a375816514636e24c0ceaf081637_130.png)

咱们这个应该是你给它传进去的这个name嘛对吧。

![](img/fd86a375816514636e24c0ceaf081637_132.png)

为什么会这样呢，为什么会这样呢，咱们可以从这从joint print一个cf点下划线result啊。

![](img/fd86a375816514636e24c0ceaf081637_134.png)

![](img/fd86a375816514636e24c0ceaf081637_135.png)

咱们可以再运行一下，看一下，你会发现它还是浪值。

![](img/fd86a375816514636e24c0ceaf081637_137.png)

两个当值了是吧，两个当值了，除非你从这print一个PRINT。

![](img/fd86a375816514636e24c0ceaf081637_139.png)

print一个cf点下划线result。

![](img/fd86a375816514636e24c0ceaf081637_141.png)

这个它不会是当值的，他应该就是睡觉是吧，他是睡觉，两个N值，一个NG值是从JOE输出的。

![](img/fd86a375816514636e24c0ceaf081637_143.png)

一个NN值是print i e s。

![](img/fd86a375816514636e24c0ceaf081637_145.png)

为什么会这样呢，其实你理解了就是他这个两个内内两块内存，它是不能共享的，之后它中间的这个信息传递，你不可能直接给他传递过去的，对不对，你肯定得通过别的方式，你直接这么传，肯定传不过去。

你从这其实是你从这输出的，这就这个result其实是在这个紫禁城里边执行的，它返回的这个result，这个JUNE一般是被主进程来调用的，是主进程调用了这个john。

你的主进程来调用了紫禁城的这个drain方法，然后你还想接到它的返回值，肯定是接触不到的，对不对，因为他们之间是不能共享的呀，所以说他就传递不过来，那如何要传递这个返回值呢。



![](img/fd86a375816514636e24c0ceaf081637_147.png)

就是或者说就是如何在这个就是进程之间实现。

![](img/fd86a375816514636e24c0ceaf081637_149.png)

![](img/fd86a375816514636e24c0ceaf081637_150.png)

就是一些数据的相互传递呢，这个咱们需要引入。

![](img/fd86a375816514636e24c0ceaf081637_152.png)

就是说这个进程之间，只见数据的相互传递，其实传递的方法很多啊，但是咱们经常会用到的就是Q，Q e e q。



![](img/fd86a375816514636e24c0ceaf081637_154.png)

你可以从q u e u e import q。

![](img/fd86a375816514636e24c0ceaf081637_156.png)

在咱们维纳那个平台最核心的那个man，那个invent engine里边其实也用到了这个Q啊。

![](img/fd86a375816514636e24c0ceaf081637_158.png)

但是咱们可以看一下这个Q这个里边啊。

![](img/fd86a375816514636e24c0ceaf081637_160.png)

他用的这个大部分它不是它不是大部分，它是用在这个threading上面的threading上面的，所以说现在给大家介绍的这个Q啊。



![](img/fd86a375816514636e24c0ceaf081637_162.png)

是用在县城中的，就是不能用在进程里边，因为它是放在线程里边去用的threading。

![](img/fd86a375816514636e24c0ceaf081637_164.png)

你看看它的源码，他上来就import threading。

![](img/fd86a375816514636e24c0ceaf081637_166.png)

所以说在进程里边是肯定是不能用的，咱们通过他先给大家介绍一下。

![](img/fd86a375816514636e24c0ceaf081637_168.png)

Q它是个什么东西，你可以把它理解为一个管道，就这个管道里边呢就是当然它在底层，它也是一个数据存储啊，但是它可以就是给你提供的方法往里边放数据，然后呢可以往里面取数据，就是往外取数据，就是一边放。

你可以一边去取数据，提供了这样的一个管，就是不是管道，这应该叫队列，就是先进去的，肯定是先出来，就是这样的方式来给你实现的啊。



![](img/fd86a375816514636e24c0ceaf081637_170.png)

它里边就是它有的方法。

![](img/fd86a375816514636e24c0ceaf081637_172.png)

咱们可以print一下啊，就是jr用这个方法QUEUEBRT一下牛啊。

![](img/fd86a375816514636e24c0ceaf081637_174.png)

![](img/fd86a375816514636e24c0ceaf081637_175.png)

这个又开始执行了啊，他的方法里边啊，他有这个什么呀，git put是吧，就是呃empty就是空for就是满了，get就是拿到这个，咱们先不说这个也不说啊，put就是往里边去放cute size。

Cusize，就是获取它的这个就是队列的大小啊，但是如果说你这个队列里边没有。

![](img/fd86a375816514636e24c0ceaf081637_177.png)

就是放这个就是没有设置这个它的大小的话，它就默认是无限格啊，咱们逐个的先介绍一下这里面的参数，在进程里面使用的这个队列，跟县城里边使用队列基本上都是一致的啊，就是只不过它导入的地方不一样。

这个是县城里面使用的，你进程里边的队列得单独去导入，但是咱们先通过这个线程的队列，跟大家介绍一下，就是里边的咱们经常用的方法，比如说我创建了一个Q，等于就是这个实例化了一个QE。

UE里边传max size，就是你最多这个队列里面放多少，你如果不写的话，或者小于零的话，它就是就是就是默认就是可以可以。



![](img/fd86a375816514636e24c0ceaf081637_179.png)

可以放任意多个啊。

![](img/fd86a375816514636e24c0ceaf081637_181.png)

然后Q点put是往这个队列里边放东西啊，然后里边这个item就是你就是需要放的东西，block就是是不是阻塞啊，比如说我放了一个，比如说我放了一个一，然后放进去了。



![](img/fd86a375816514636e24c0ceaf081637_183.png)

然后block是不是阻塞，如果说我设置成true。

![](img/fd86a375816514636e24c0ceaf081637_185.png)

就是他会一直等着，就是如果说他在什么情况下，他会一直等着呢，就是我放不进去的时候，你设置了这个里边最大值是吧，比如最多放十个，我是第11个往里放，我会一直等着，就是等到他就是说能放的时候再放进去。

然后后边还有个参数叫做time out，Time out，它是设置了什么呢，我等待的时间，就比如说我等待了我设置了一秒，如果说我等待了一秒钟，然后那个我还没放进去，它就会报错。

就是这个是time out的，就是说作用，这是两个参数。

![](img/fd86a375816514636e24c0ceaf081637_187.png)

好吧，这是put，其实Q点git也是一样的。

![](img/fd86a375816514636e24c0ceaf081637_189.png)

就是当然他不用去放数据，但是你需要取数据，你是不是要要这个block block，就是需不需要阻塞着等，就是我如果取取不着的话，我会一直等下去，如果你给他设置了一个time out，就是限定一个时间。

如果等不到的话，我就报错，会报那个就是mt就是空的，你这个队列里边是空的。

![](img/fd86a375816514636e24c0ceaf081637_191.png)

empty啊，就会报这个错误好吧，这是Q点git。

![](img/fd86a375816514636e24c0ceaf081637_193.png)

然后Q点，还有什么empty咱们就不用说了。

![](img/fd86a375816514636e24c0ceaf081637_195.png)

是不是是否为空是吧，然后Q点four就是这个是不是满了啊，然后Q点q size，还有个这个Q点size还是q size啊，q size是判定当前这个队列里边的这个长度啊。

就是这个size基本上常用的就这么几个，尤其是get和put啊，具体的在进程里边如何去使用啊，就是说基本上进程里边，这个Q和这个县城里边Q都是一样的，只不过他们导入的方式不一样，一个是直接导入这个。

然后进程里边需要单独去导入，给大家做一下演示。

![](img/fd86a375816514636e24c0ceaf081637_197.png)