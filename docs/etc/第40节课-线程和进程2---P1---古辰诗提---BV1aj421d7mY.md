# 第40节课 线程和进程2 - P1 - 古辰诗提 - BV1aj421d7mY

欢迎大家来到从零开始量化系列课程，Python基础课的第40课，这节课呢咱们接着讲线程，上一节课的这个全局锁gear，大家一定要理解他为什么说Python，它就是说没有真正意义上的多线程并行。

原因就在这个gear所gear，它就是他的这个创造啊，其实是为了什么呀，实现数据的准确不被污染，你说它有好处吗，它有很多的好处，不然的话当时也不会被创造出来，但是当时的这种情况只有单线程。

不是只有单核的这种CPU，但是进入20世纪以后，多核的发展就显得这个gr所很兽人，这个诟病对吧，但是呢很多大佬们尝试着把这个盖尔索给拿掉，但是都会影响到什么呀，他在单进程里边的速度。

所以说一直没有成功啊，这一点你一定要理解它，包括你理解的gear，你就能理解这个为什么需要有线程锁，虽然Python在底层，尤其是咱们这Python都指的c Python，c Python在底层底层。

其实很多的这个数据类型上都给加了全局锁了，但是如果说你这个多线程，要使用到公用数据的话，你一定记得最好是加上这个线程锁，不然很容易出现问题，就是数据的混乱啊，好上一节课呢给大家创建了两个线程。

加上主线程也就是三个线程对吧，那如果说我要创建20个线程，我如何去创建呢，那很简单，就用循环嘛对吧，for i啊。



![](img/ea0382675c3de1b6f64a2f819236519a_1.png)

In range，比如说这个我别创建20个了。

![](img/ea0382675c3de1b6f64a2f819236519a_3.png)

我创建五个吧，然后T等于thread。

![](img/ea0382675c3de1b6f64a2f819236519a_5.png)

然后里边target target t target等于task。

![](img/ea0382675c3de1b6f64a2f819236519a_7.png)

![](img/ea0382675c3de1b6f64a2f819236519a_8.png)

它可以等于task给它传入参数，咱们一直在强调要用元组对吧，name就是睡觉，睡觉，然后执行时间是两秒钟。



![](img/ea0382675c3de1b6f64a2f819236519a_10.png)

然后你一定要记得啊，这个要ARJS，等于你一定要记得在这要给它start起来是吧，如果说咱们要计时的话，import一个time tom上节课也说过啊，他是时间戳呃。

start等于T结束的时间就是end等于time，然后用print一个总用时。

![](img/ea0382675c3de1b6f64a2f819236519a_12.png)

![](img/ea0382675c3de1b6f64a2f819236519a_13.png)

然后秒是吧，第2format end减start啊。

![](img/ea0382675c3de1b6f64a2f819236519a_15.png)

这个时候你这么运行的对吗对吗，他肯定不对啊，因为主线程它到这给它创建好了，启动了之后，他就会接着往下来运行的，它不会等到你这执行完了之后，所有的线程执行完了之后才运行下边，所以说你需要给他们添加JOE。

这样的话就有很多老板就从这儿来添加JUNE了，这样添加是肯定是不对的，这样只能实现串行，咱们运行一下，因为你在循环的时候。



![](img/ea0382675c3de1b6f64a2f819236519a_17.png)

你到这儿就进行等待了对吧，你到这儿进行等待了。

![](img/ea0382675c3de1b6f64a2f819236519a_19.png)

就整个代码主线程的代码就被你卡住了，你得等他执行完了之后，你才能进行下一次循环，所以说他用了十秒钟，就是每一个两秒，你五个线程不就是十秒钟吗，你这样就没有多线程的意义了，对不对。

你只能是把这个T点JOE放在外边，那放在外边，我怎么去做呢，你可以从这T下划线list，我给它创建一个这个列表，然后它每创建一个线程类的对象，我就给它添加到这个列表里边去append。



![](img/ea0382675c3de1b6f64a2f819236519a_21.png)

然后这个把T放进去。

![](img/ea0382675c3de1b6f64a2f819236519a_23.png)

灯在我的这个主线程里边，这块代码执行完了，这里边应该也添加出五个这样的线程了对吧，然后我在for t n t list，然后T点join。



![](img/ea0382675c3de1b6f64a2f819236519a_25.png)

我挨个的给它进行阻塞。

![](img/ea0382675c3de1b6f64a2f819236519a_27.png)

然后这个时候你才是你真正的要实现，要实现的这个效果，对不对好，你看它是一起来执行的，然后一起执行结束，总共耗时两秒，你一定要注意这个john的添加，其实JN的添加，你一定要知道这个主线程和子线程的。

它的运行的情况，你执行这块代码，你就是代码由由由上而下来执行，肯定是主线程在执行的啊，主线程在执行的，然后你创建的子线程，你一定要把这个JOE放到合适的位置，放到合适的位置好吧。



![](img/ea0382675c3de1b6f64a2f819236519a_29.png)

这个呢是咱们经常这么用到的，但是你在正常执行的时候。

![](img/ea0382675c3de1b6f64a2f819236519a_31.png)

你说我执行创建的线程是越多越好嘛，肯定不是的，当然你在创建线程还是创建进程的时候，你一定得有所选择，根据你的任务，县城一般是用在比如说像爬虫，或者说比如说像这个IOI就是INO，就是out。

就是你写信写出像这样的一些操作，它并不会密集的使用到计算，也就不会密集的使用到CPU，所以像这样的，你可以就是说使用多线程，比如像咱像咱们量化里边，比如处理数据的时候，是数据密集型的这样的一种方式的话。

你就要用到多进程，多进程比多线程，对于这个计算机的消耗肯定要更加的大，所以说你这个一定要知道它适用的场景，另外就是说我是不是创创建的线程越多越好呢，其实也不见得你创建线程，它一方面是消耗了你的这个资源。

计算机的资源，另一方面也需要时间去创建的对吧，不一定是创建的线程越多越好，可能我就需要十个线程来运行，我100个任务，这样是最合适的，免去了我挨个去创建线程，执行这样代码的时间是吧。

这些任务他可能也是断断续续的，所以说这样是最好的，就是它在对于CPU的使用上，它不是连续的计算型的，就是这个你可能十个任务啊，十个县城是最好的，那十个县城呢你有100个任务，他就得需要调度。

就是我什么时候我这个任务执行完了，我再把另外一个任务给放进来，这就需要一个线程池。

![](img/ea0382675c3de1b6f64a2f819236519a_33.png)

这节课呢咱们主要讲一下线程池，线程池也很好理解，你可以把它理解为池子这个池子里边创建了，比如说最多创建十个线程，他当然不会，比如你的任务只有五个，他不会特别傻的去创建十个线程，它可能就创建五个。

但是最多是创建十个线程啊，创建十个线程，如果比如说你有100个任务过来了，他会先把这个100个任务呢放进池，放进这个池子里边，然后先去执行十个任务，当其中有执行完成之后，它会实现现成的复用，好复用啊。

它会实现线程的复用，我这个县城会再去执行下一个任务，他是这样进行的一个操作呃，首先你得导入这个包对吧，怎么导入呢，from它是在这个里面的。



![](img/ea0382675c3de1b6f64a2f819236519a_35.png)

Concurrent，第2futures import。

![](img/ea0382675c3de1b6f64a2f819236519a_37.png)

这个three的线程poor就池，然后后边的意思是执行者，这个单词我不太会读啊。

![](img/ea0382675c3de1b6f64a2f819236519a_39.png)

如何去使用，我先把这给注释掉，注释掉。

![](img/ea0382675c3de1b6f64a2f819236519a_41.png)

比如我创建我首先我得创建一个池子对吧。

![](img/ea0382675c3de1b6f64a2f819236519a_43.png)

poor等于，然后这个线程池进行实例化。

![](img/ea0382675c3de1b6f64a2f819236519a_45.png)

后边呢有几个参数，第一个参数是max workers，其实他的意思就是说，你最多的就是这个工作人员，Worker，工人就是他是把线程比作了，就是这个公认嘛max worker就是最多有多少个线程。

比如说我最多是三个线程。

![](img/ea0382675c3de1b6f64a2f819236519a_47.png)

三个线程，那我怎么使用这个线程池呢，就是破点。

![](img/ea0382675c3de1b6f64a2f819236519a_49.png)

去申请啊，然后我申请使用线程，然后这个里边呢，你要把这个你的这个任务给它传进去。

![](img/ea0382675c3de1b6f64a2f819236519a_51.png)

同样后边你得需要传参数，但这个传参数跟咱们那个thread去传参数要注意了，thread咱们是用了一个括号，是用的这个元组去传，但是这个呢是顺序的把参数往后边去放啊，顺序的往把参数往后边去放好吧。



![](img/ea0382675c3de1b6f64a2f819236519a_53.png)

你一定要记住这个啊，顺序的把参数往后边去放，咱们可以看看这个，他在这个括号里边。

![](img/ea0382675c3de1b6f64a2f819236519a_55.png)

你看看target，他会给你指定一个元组是吧。

![](img/ea0382675c3de1b6f64a2f819236519a_57.png)

target没有加星号，但是这个里边你会发现。

![](img/ea0382675c3de1b6f64a2f819236519a_59.png)

Task，这个里边是新ARGS，新lg s，咱们之前在讲这个时候说过，新号其实就是脱了一层衣服，他既然已经把衣服给脱了，所以说你这里边就不用加括号了，就按顺序往里填就可以了，好吧。

一定要理解这个理解了你很多，当你再看到比如说有新lg的时候，你就知道这个里边不用去给gs传一个元组，他已经给你把衣服脱了啊。



![](img/ea0382675c3de1b6f64a2f819236519a_61.png)

这个name比如说就是睡觉。

![](img/ea0382675c3de1b6f64a2f819236519a_63.png)

然后吃饭啊，不是这个tom，比如三秒钟。

![](img/ea0382675c3de1b6f64a2f819236519a_65.png)

这个时候你只要去运行它就可以了，睡觉任务开始执行，然后睡觉任务执行结束对吧，如果是多任务的话，比如说我for，for i in range120吧，这样咱们少一点少一点，因为它只有三个齿呃，三个线程嘛。

这个时候submit，咱们任务呢后边加上一个什么呀，就是加上STR，把这个I放进去，这样有一个标识对吧，让他睡就睡两秒吧，然后十个吧，水少一点。



![](img/ea0382675c3de1b6f64a2f819236519a_67.png)

然后print一下，咱们是主线程。

![](img/ea0382675c3de1b6f64a2f819236519a_69.png)

执行结束咱们可以再看一下。

![](img/ea0382675c3de1b6f64a2f819236519a_71.png)

就是当前的这个线程的情况对吧。

![](img/ea0382675c3de1b6f64a2f819236519a_73.png)

它一共有多少个线程在执行，当前执行的线程。

![](img/ea0382675c3de1b6f64a2f819236519a_75.png)

一共是比如说括号这里边应该是啊，这多了一个，这个一共是个点format。

![](img/ea0382675c3de1b6f64a2f819236519a_77.png)

然后这里边应该是LN。

![](img/ea0382675c3de1b6f64a2f819236519a_79.png)

然后括号里边是threading点。

![](img/ea0382675c3de1b6f64a2f819236519a_81.png)

就是这个应该是IMMATE吧，mate这个就是练就是获取它的长度嘛，好这个时候咱们看一下啊，看一下，当前执行的线程一共是四个是吧，一一共是四个，一共是四个，为什么是四个，它只有三个嘛。

你还得加上一个主线程啊，对不对，你还得加上一个主线程吧，你会发现到任务久睡觉久啊，这是是十个是吧，就是十啊，这是任务九，这个没有问题，就是到任务九的时候，他就执行结束了对吧，但是你会发现主线程执行结束。

它早就结束了，它的其实整个的代码逻辑是什么样的，就是当我把任务甩给县城池之后，然后他就是这个代码会接着往下走，以前咱们用threading的时候，你用那个john来给它从这阻塞住，对不对。

当如果说你想从这阻塞的时候。

![](img/ea0382675c3de1b6f64a2f819236519a_83.png)

你不希望他就是说，就是说一下子主线程就执行完了，你从这需要加上一个什么呢，就是p shut down等于一个true。



![](img/ea0382675c3de1b6f64a2f819236519a_85.png)

![](img/ea0382675c3de1b6f64a2f819236519a_86.png)

pull shut down等于一个true，这个时候咱们来看一下啊，Cs，当前直线的执行的线程一共是四个，一定要知道为啥是四个啊，三个子线程加一个主线程，你看他这个都执行完了之后，主线程执行才结束。

从这儿你会发现。

![](img/ea0382675c3de1b6f64a2f819236519a_88.png)

就是说，其实他和咱们之前讲的现成的方式和方法，基本上都是差不多的，唯一的注意点就是你在传参的时候需要去注意，如果说你理解了之前讲的那个线程，到这你应该就很容易去理解这个shut down。

其实就相当于那个john对吧。

![](img/ea0382675c3de1b6f64a2f819236519a_90.png)

但是呢这个里边呢还有一些别的功能，别的功能。

![](img/ea0382675c3de1b6f64a2f819236519a_92.png)

就比如说当我这个执行完了之后，我想获得返回值，我从哪去获得这个返回值。

![](img/ea0382675c3de1b6f64a2f819236519a_94.png)

就这个返回值我从哪去获得，从这儿呢，你可以用一个FU去接一下。

![](img/ea0382675c3de1b6f64a2f819236519a_96.png)

为什么用FU，因为这个futures我用一个FU去接一下。

![](img/ea0382675c3de1b6f64a2f819236519a_98.png)

然后呢我同样的一个列表list，等于这个我把这个FU我给它加到这个列表里边，去加append这个FU，我想获取他的这个所有的结果的话，是不是都得等着执行完毕之后呢，都等着执行完毕之后。

我for f u in啊，F u list，然后它有什么FU点，RESUISULT括号，它有一个FU点，Result，就是它的结果它会给它封装到这个里边来啊。



![](img/ea0382675c3de1b6f64a2f819236519a_100.png)

print f u点result，咱们可以看一下。

![](img/ea0382675c3de1b6f64a2f819236519a_102.png)

他执行结束了，他执行结束会把睡觉领到，睡觉九全部给你输出出来对吧，他这个返回的这个类型是什么类型呢。

![](img/ea0382675c3de1b6f64a2f819236519a_104.png)

跟大家说一下，就是在还是在这个from current这个concurrent futures。

![](img/ea0382675c3de1b6f64a2f819236519a_106.png)

点下划线，base import一个大写的FUT啊，Filter，从这这个filter你会发现它是一个，就是说也也是一个类吗，它返回的就是这个类啊。



![](img/ea0382675c3de1b6f64a2f819236519a_108.png)

然后其实你可以把它理解为它是一个数据类型，他返回的这个FU其实是个数据类型。

![](img/ea0382675c3de1b6f64a2f819236519a_110.png)

如果说你把这个FU给标注一下这个future future。

![](img/ea0382675c3de1b6f64a2f819236519a_112.png)

你会发现这就变黄了啊，就是你要知道他是这个F就是future这个future里面。

![](img/ea0382675c3de1b6f64a2f819236519a_114.png)

你有你也可以去翻翻他的这个源代码。

![](img/ea0382675c3de1b6f64a2f819236519a_116.png)

翻翻他的源代码好吧，然后呢，比如说我还有一个需求，我先把它给注释掉，我还有个需求，就是这你这样写显得也有点傻，我想让他执行完了之后去执行一个方法。



![](img/ea0382675c3de1b6f64a2f819236519a_118.png)

就是他执行完了之后，就是这个池子里边，县城每一个线程执行完了之后去执行一个方法，这个我应该怎么去做啊。



![](img/ea0382675c3de1b6f64a2f819236519a_120.png)

怎么去做，就是比如说我定一个方法，Df down，就是做完的，意思是他会把这个这个大写的这个future。



![](img/ea0382675c3de1b6f64a2f819236519a_122.png)

就是这样的类型给你返回出来，就这个东西给你返回出来。

![](img/ea0382675c3de1b6f64a2f819236519a_124.png)

所以说你这一定得有一个接的东西，比如说我就用FU接。

![](img/ea0382675c3de1b6f64a2f819236519a_126.png)

它是一个future，然后我还是print一下，当然我就是做个演示啊。

![](img/ea0382675c3de1b6f64a2f819236519a_128.png)

result把它的结果给输给输出出来。

![](img/ea0382675c3de1b6f64a2f819236519a_130.png)

然后我还是从这儿，我需要等待着它，但是它有一个方法叫call out，第二。

![](img/ea0382675c3de1b6f64a2f819236519a_132.png)

啊不对啊，不是他啊，是这啊，咱们现在不接他了啊，不用去接他了，然后这里边有一个FU点。

![](img/ea0382675c3de1b6f64a2f819236519a_134.png)

Add down call back，就是我添加做完了之后的一个回调方法。

![](img/ea0382675c3de1b6f64a2f819236519a_136.png)

我把这个回调方法这个down方法给它传进去啊，这个时候它会实现跟刚才一样的效果。

![](img/ea0382675c3de1b6f64a2f819236519a_138.png)

其实就是把它的结果就是这个你这个对象嘛。

![](img/ea0382675c3de1b6f64a2f819236519a_140.png)

执行完成这个对象，这个结果回掉它这个down啊，给他传递的就是这个fu future future，它是被一个包装了的一个对象，它的返回结果这个时候的运行是一样的，你看它会输出F0。

它它会在一个线程结束之后，他会输出是吧，睡觉当你睡觉一执行完了之后，不执行结束之后，他会给你输出出来对吧，这样就没有问题了，就是在你这个线程执行完之后。



![](img/ea0382675c3de1b6f64a2f819236519a_142.png)

它会调用的这个方法，另外咱们在之前看这个里边的方法的时候，你会看见的max workers后边还有three name prefix，Serial name prefix，这个很好理解啊。

就是现成的名称的前缀是吧。

![](img/ea0382675c3de1b6f64a2f819236519a_144.png)

好咱们加上一个前缀，比如说我就前缀这个就是说这个task前缀，这个时候啊我挨个去就是输出这个FU一下。



![](img/ea0382675c3de1b6f64a2f819236519a_146.png)

就是我这个线程对象，线程对象，或者说我从这我print一个。

![](img/ea0382675c3de1b6f64a2f819236519a_148.png)

就是当前执行的这个线程啊。

![](img/ea0382675c3de1b6f64a2f819236519a_150.png)

当前执行threading，第二这个还是这个就是mate。

![](img/ea0382675c3de1b6f64a2f819236519a_152.png)

还是就是这个枚举类是吧，好我运行一下，你会发现从这啊，你会发现它的这个名字啊，task它会给你自己去复制task0，Task1，Task2，它的名字就变了啊，这是给他改名字的，就是这个后边啊。

就是这个这个是他名字的一个前缀好吧。

![](img/ea0382675c3de1b6f64a2f819236519a_154.png)

后边它还有一个参数，这个参数是干嘛的呢，这个参数是干嘛的，INIT就是在初始化的时候。

![](img/ea0382675c3de1b6f64a2f819236519a_156.png)

咱们可以试一下啊，比如说定义一个INIT。

![](img/ea0382675c3de1b6f64a2f819236519a_158.png)

我就print一个。

![](img/ea0382675c3de1b6f64a2f819236519a_160.png)

开始拉线程池县城池要啊要开始了。

![](img/ea0382675c3de1b6f64a2f819236519a_162.png)

好咱们来把这个再给它传进去，INIT这个方法给他传进去，咱们来看一下好吧，线程池要开始了，线程池要开始了啊，执行结束是吧，你会发现这个线程池要开始了，线程池要开始了，它执行了几遍三遍，他执行了三遍线程。

就是你第一次这个子线程在执行的时候，第一次来执行的时候，它会调用这个，你就是在执行之前啊，在执行之前就是它会调用你这个方，你这个方法它会调用你这个方法啊。



![](img/ea0382675c3de1b6f64a2f819236519a_164.png)

这个是你想其实你理解他的这个INIT啊，他这个意思就可以了，后边的咱们就不介绍了。

![](img/ea0382675c3de1b6f64a2f819236519a_166.png)

基本上用的不会特别多，包括这个后边两个也用的不是特别多啊，也用的不是特别多好吧。

![](img/ea0382675c3de1b6f64a2f819236519a_168.png)

这就是线程池的用法，主要的就是它的一个shut down。

![](img/ea0382675c3de1b6f64a2f819236519a_170.png)

还有他创建的方式以及它运行的方式，它另外还有一个就是前置的调用。

![](img/ea0382675c3de1b6f64a2f819236519a_172.png)

就是在线程池开始的时候去进行调用的，还有一个就是线程池结束之后，这个会经常用到的，就是它线程池执执行结束之后，它的一个返回对象会返回给你。



![](img/ea0382675c3de1b6f64a2f819236519a_174.png)

就是传进来的这个方法啊，这个方法同时如果说你要想看当前的线程呃，就用这个emate mate，然后shut down是跟john是类似的，这个就是线程池的一些介绍。



![](img/ea0382675c3de1b6f64a2f819236519a_176.png)

好县城讲完之后，咱们就要讲进程了，进程其实和县城方法很类似，但是它们本质上是有区别的，本质上最大的区别是在哪呢，线程它是多线程。



![](img/ea0382675c3de1b6f64a2f819236519a_178.png)

它是共用一块内存空间，就是他们是在一起的，共用一块内存空间，所以说里面的变量它会有，这个就是有共用的这个可能性，但是进程池进程它是不一样的，你多进程它其实不用的不是同一块内存空间。

它会给你重新开辟一块内存空间，比如说我这个是主进程，紫禁城会单独开辟一块空间，你紫禁城所要用到的资源啊，你紫禁城所要用到的资源，都是从主姓称这拷贝过去的，拷贝过去的，或者给你传过去的。

它的机制呢也不太一样，就是在OS或者说那个UNIX或者LINUX那个系统里边，它是用fork fork的方式，他会把里边就是主进程里边，所有的变量都给你拷贝一份，到紫禁城里边去。

但是在咱们windows呢，是在咱们windows里边是用这样的方法，这个sport这样的方法就是A啊，这样的方法呢，他会把必要的一些你里边的需要用到的，就是说这个变量或者这个函数。

通过传参的方式传给紫禁城，所以说它是有区别的，当然咱们主要了解的是，咱们这个在windows下如何去使用好吧。



![](img/ea0382675c3de1b6f64a2f819236519a_180.png)

如何去使用好进程的这个，英文process，然后它的这个类就是from multiprocessing import process，Muli，就是多个processing。

import process啊，其实它里边的方法其实跟线程是很类似的啊，咱们把这个39给打开。

![](img/ea0382675c3de1b6f64a2f819236519a_182.png)

向右拆分一下，然后找一下之前的咱们需要用的这个task。

![](img/ea0382675c3de1b6f64a2f819236519a_184.png)

一样的吧，我就从从上面给他拷贝啊。

![](img/ea0382675c3de1b6f64a2f819236519a_186.png)

40从上面拷贝吧。

![](img/ea0382675c3de1b6f64a2f819236519a_188.png)

这个。

![](img/ea0382675c3de1b6f64a2f819236519a_190.png)

好这样的一个就是进程我要执行方法，同样的其实就是还是比如说我P等于process，然后这个里边一样的target t a r gt target等于task，然后你参数的传递。

咱们可以看一下name august august augus，它没有加星号。

![](img/ea0382675c3de1b6f64a2f819236519a_192.png)

所以说你可以把这个ARGUS，一定要用这个位置参数给它传进去。

![](img/ea0382675c3de1b6f64a2f819236519a_194.png)

ARGUS里边name就是说睡觉，然后时间两秒钟是吧，然后P1定要还有一个start啊，其实他也是执行里边的那个run方法，跟咱们的县城是很类似的。



![](img/ea0382675c3de1b6f64a2f819236519a_196.png)

同样的你P点john也是得有的，这样咱们还会输出一个print end是吧。

![](img/ea0382675c3de1b6f64a2f819236519a_198.png)

end如果说你没有join的话，他可能就是先end啊。

![](img/ea0382675c3de1b6f64a2f819236519a_200.png)

先end，咱们去执行一下，这出现了一个错误啊。

![](img/ea0382675c3de1b6f64a2f819236519a_202.png)

错误主要出现问题，你会发现下划线name等于下划线ma，所以说进程你要去运行它，你必须得在前面加上一副这个下划线，men等于下划线name，这个是一定得有的啊，一定得有的。

并不一定就是说你创建这个是放在这儿。

![](img/ea0382675c3de1b6f64a2f819236519a_204.png)

你如果说有个方法，比如说我这create c r e a t create process，你把这个放在这个里边也行，但是你执行的时候，你一定要放在下划线，就是说下划线下划线man等于下划线。

下划线name这个里边儿啊，一定要注意，你这个时候再来执行，咱们可以看一下end，它已经执行end了是吧，如果说你这有个JOE的话，啊睡觉任务开始执行，然后这个是放在最后的，这个跟县城是类似的。

同样这个里边也可以给它命名。

![](img/ea0382675c3de1b6f64a2f819236519a_206.png)

name等于比如说我紫禁城紫禁城一是吧。

![](img/ea0382675c3de1b6f64a2f819236519a_208.png)

![](img/ea0382675c3de1b6f64a2f819236519a_209.png)

这个时候你print一下，print一下这个怎么获取啊。

![](img/ea0382675c3de1b6f64a2f819236519a_211.png)

P点name是吧，同样的它也可以什么呀，就是说P点cat，P点哎就是没有sit name了啊，就直接name等于可以去变的啊，包括P点守护进程等于什么也是可以去，是不是守护进程。

这个跟这个线程是很类似的。

![](img/ea0382675c3de1b6f64a2f819236519a_213.png)

包括在这你也可以设置它是不是守护进程是吧，比如说我C啊。

![](img/ea0382675c3de1b6f64a2f819236519a_215.png)

给他设置一个不是守护进程，不是守护进程啊。

![](img/ea0382675c3de1b6f64a2f819236519a_217.png)

你如果是射程守护进程的话，还是给大家演示一下吧。

![](img/ea0382675c3de1b6f64a2f819236519a_219.png)

你不能有这个drain对吧，这个也也别写了是吧，这个你如果是这么设设置守护进程的话，它会立马就结束掉，就自行程一就end了，你print的是print这个name，自行车一就end的。

如果说你把它设置成不是守护京城，他会给你就是等待着，虽然in的中间就结束掉了，但是主进程就结束掉了，但是紫禁城同样会进行执行，这个跟这个县城是大同小异的。



![](img/ea0382675c3de1b6f64a2f819236519a_221.png)

唯一有区别的呢线程啊不是进程，你是可以获取到它的进程id的啊。

![](img/ea0382675c3de1b6f64a2f819236519a_223.png)

可以获取到它的进程id的。

![](img/ea0382675c3de1b6f64a2f819236519a_225.png)

就比如说我从这我获取一下主进程的id，print一下主进程的id是是这边加个括号format。

![](img/ea0382675c3de1b6f64a2f819236519a_227.png)

![](img/ea0382675c3de1b6f64a2f819236519a_228.png)

![](img/ea0382675c3de1b6f64a2f819236519a_229.png)

然后这里边os gate API d。

![](img/ea0382675c3de1b6f64a2f819236519a_231.png)

OS点GPID，然后如果说我想获取一下紫禁城的。

![](img/ea0382675c3de1b6f64a2f819236519a_233.png)

就从这print一下紫禁城的。

![](img/ea0382675c3de1b6f64a2f819236519a_235.png)

![](img/ea0382675c3de1b6f64a2f819236519a_236.png)

紫禁城的id是同样的。

![](img/ea0382675c3de1b6f64a2f819236519a_238.png)

这边点format括号OS点gate这个PID好。

![](img/ea0382675c3de1b6f64a2f819236519a_240.png)

![](img/ea0382675c3de1b6f64a2f819236519a_241.png)

咱们可以来运行一下，看一下是吧。

![](img/ea0382675c3de1b6f64a2f819236519a_243.png)

主进程的id是19788，紫禁城的id是2695626956啊，这就是呃主进程的id和紫禁城的id。

![](img/ea0382675c3de1b6f64a2f819236519a_245.png)

你还可以从这获取到什么呀，就是主进程的id。

![](img/ea0382675c3de1b6f64a2f819236519a_247.png)

从这获取一下主进程的id，然后呢一个是PPITP，你可以理解为是parent。

![](img/ea0382675c3de1b6f64a2f819236519a_249.png)

Parent，Parent，不就是也就是他的这个就是上一个的这个id吗。

![](img/ea0382675c3de1b6f64a2f819236519a_251.png)

主进程的id是2504是吧，这个2504两个是一样的啊，就是这个get pai d啊。

![](img/ea0382675c3de1b6f64a2f819236519a_253.png)

别的基本上和这个咱们的县城是类似的。

![](img/ea0382675c3de1b6f64a2f819236519a_255.png)

![](img/ea0382675c3de1b6f64a2f819236519a_256.png)