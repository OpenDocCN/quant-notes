# B站强推！基于Python机器学习的金融分析量化交易实战居然被同济大佬老如此通俗易懂的讲解出来，三小时即可吃透！ - P67：.4-训练模型与效果展示 - 迪哥AI课堂 - BV1hZ421W7u8

![](img/f6e5d8b280755015a548f5291e1fd5ed_0.png)

然后呢，接下来呃咱们要去加载我的一个训练数据了，网络模型是已经有了，那是不是说我得按照咱们之前的一个要求，按照我们模型的一个结构去构建一下，咱们这个输入数据长什么样子，为你做这样一件事吧。

那下面我就得把这个X，还有这个Y实际做出来吧，在这里啊，重新的我做一个函数data来看data在哪之前。



![](img/f6e5d8b280755015a548f5291e1fd5ed_2.png)

咱是不是有一个预处理函数，在这里。

![](img/f6e5d8b280755015a548f5291e1fd5ed_4.png)

是不是我们定义了一个类啊，这个类当中有这样一个函数，我直接跳进去吧。

![](img/f6e5d8b280755015a548f5291e1fd5ed_6.png)

就是一个get train data来看一下，首先传进来几个参数额，这个这个后后面后面这暂时不需要，咱们就说咱们先说简单的，就是我们现在这里传进来一个50，这个50表示什么，我的一个序列的一个长度吧。



![](img/f6e5d8b280755015a548f5291e1fd5ed_8.png)

来看吧，首先X我的一个Y我们现在都给它空出来。

![](img/f6e5d8b280755015a548f5291e1fd5ed_10.png)

是不是先定义一个绿色的结合，然后呢在这里我们要怎么去做啊，咱们来想我们现在一共能有多少个序列出来啊，咱们现在说一下每一个序列的长度，诶，我的画笔呢在这里每一个序列长度，它是不是一个50啊是吧。

这是第一个50，然后下面呢就是另一个50，另一个50是不是在这里，我们一共能有多少个50啊，我们应该用总长度4000减去序列长度50吧，为啥呀，你想啊，就是说最后一个序列它不能超，它不能越界吧。

所以说最后一次的时候他没法再往后移了，所以啊我们只有4000-50啊，这么多个序列在这里写个for循环。



![](img/f6e5d8b280755015a548f5291e1fd5ed_12.png)

For i in range，我的一个4000-1个50啊，是这个意思行了，X和Y我要取数据了吧。

![](img/f6e5d8b280755015a548f5291e1fd5ed_14.png)

咱咋取啊，这东西你说我说第第一个是从0~50，加一个01~51，那是不是一个2~52，那它是不是一个滑动窗口的一个感觉啊。



![](img/f6e5d8b280755015a548f5291e1fd5ed_16.png)

我们是不是得做一个窗口来去不断取数据啊。

![](img/f6e5d8b280755015a548f5291e1fd5ed_18.png)

在这里啊，我们定义了一个函数叫做一个nice window，我们直接呃来看一下在哪呢。

![](img/f6e5d8b280755015a548f5291e1fd5ed_20.png)

这个函数是吧，我们直接F5跳进去就可以了，直接F5跳进去。

![](img/f6e5d8b280755015a548f5291e1fd5ed_22.png)

nice window当中，首先告诉我长度，它是等于51开始，它的一个位置是零，是不是行了，那就是从0~50这个位置呗，有了一个start索引，有了一个and索引，是不是我的一个start。

就是开始start，加这个and就是一个结束吧，通过我的索引先把第一个窗口取出来，这是我第一个窗口当中所有的数据吧，你看此时所有的窗口数据我是不是都拿到手了，在这里所有窗口数据我全部已经拿到手了。

有了这个窗口数据之后，接下来我们做些什么事，接下来啊我们要去把这个东西啊，现在我们现在不用去做这个归一化这个操作，直接把数值拿过来就可以了，因为这个数值本身它就是一个0~1之间的。

在这里先把这个数值拿过来，拿过来之后，我们直接把这个，因为这个是else window啊，相当于这一步操作没做，直接把window拿过来了，这就是我当前的这个数据啊，直接拿过来了，那你说X是什么。

X哎这里你看一个窗口是50，那我说X是不是前49个当做我的一个输入，最后呢我的一个Y它是第50个吧，我写这这这么的吧，写个0~49，这个Y它是第50个，可以这么定义吧，前面49个是time step值。

最后一个Y是要预测的一个结果。

![](img/f6e5d8b280755015a548f5291e1fd5ed_24.png)

这么定义可以吧，那你看我最后一个结果，那就是最后一个值呗，X是这样的一个序列，Y呢是我最后它的一个值，那现在是不是说我定义完了，第一个窗口当中的X49个和一个Y1个值。



![](img/f6e5d8b280755015a548f5291e1fd5ed_26.png)

我都定义好了吧，return回去就可以了，这第一步，第一步，X1个序列Y1个值是不是把它俩对应起来啊，一一对应的关系，所以说data x点append x data y是不是要append y啊。



![](img/f6e5d8b280755015a548f5291e1fd5ed_28.png)

在这里我第一个序列哎，就是第一组输入啊，就做好了啊，49个输入步长一个预测的值做好了。

![](img/f6e5d8b280755015a548f5291e1fd5ed_30.png)

下面第二个，第二个是不是I从一开始了一到多少啊。

![](img/f6e5d8b280755015a548f5291e1fd5ed_32.png)

之前你这个长度现在它变一了。

![](img/f6e5d8b280755015a548f5291e1fd5ed_34.png)

是不是1~1个跳进去看一下吧，在这里这是一个一。

![](img/f6e5d8b280755015a548f5291e1fd5ed_36.png)

这是多少，I150得51，是不是像我刚才说的，一开始0~50。

![](img/f6e5d8b280755015a548f5291e1fd5ed_38.png)

然后下一个1~50，12~52，我们需要把每一个时间序列数据都做好吧。

![](img/f6e5d8b280755015a548f5291e1fd5ed_40.png)

在这里不用一个去看了吧，打个断点直接执行一下，当我执行到这一步的时候，相当于我已经把所有的序列都做好了，一共咱的输入序列是有多少个，3950个啊，这是我的输入序列有3950个，相当于我数据大小啊。

就是3950了。

![](img/f6e5d8b280755015a548f5291e1fd5ed_42.png)

这个意思行了，return回去了，我现在是不是已经把X还有这个Y都做好了，已经把X和Y都做好之后，打印一下shift值，这个shift值是这样啊，大家在自己训练训练的时候啊，你可以不去打印这个东西。

但是啊你在debug过程当中，我是建议大家每一步你都尽可能打印出来，看一看，我给大家说啊，可能大家觉得比较容易，以后啊，大家在自己做一些实际任务的时候，你可能会参考一些同事的。

或者是参考一些其他人去写的，当我们拿到一份陌生的代码，不太熟悉的东西的时候，怎么样能最好理解啊，通过数据维度不不断计算完之后，不断处理完之后看一下维度哎，变成什么东西了，基本上就是现在我养成个习惯。

你一看这个维度，我一看这个东西。

![](img/f6e5d8b280755015a548f5291e1fd5ed_44.png)

39504十九一意思说实在的一打眼，你是不是就知道这不就是个RN的输入吗，首先第一个维度是多少，你的一个数据吧，就相当于是N，我们先不说这个bad size这个东西。

到时我们要切better size嘛，第二维度我们输入了一个time style，一个步长吧，我写个S吧，第三个维度每一个步长它向量的大小吧，一这数字就定义好了，所以说啊。

我建议大家每一步都打印它的一个shift值，看一看都是什么东西，一打眼啊就明白了，Y有多少个，3950个吧，那每一个回归任务是不是就一个值啊，那不就一个吗，如果是分类任务呢，那这一块十分类。

那它不就是个十吗。

![](img/f6e5d8b280755015a548f5291e1fd5ed_46.png)

往后的coding是吧，这样我现在就已经有了一个输入的数据，那接下来我要做的是不是说把我的数据，把我的模型结合在一起了。



![](img/f6e5d8b280755015a548f5291e1fd5ed_48.png)

我训练不就完了吗，model我点train一下，是不是把需要传进来的东西传进去，epoch在这里一会儿它会设二，BESIZE是32DIR你自己指定。



![](img/f6e5d8b280755015a548f5291e1fd5ed_50.png)

这是我们true模块吧，true模块我们可以指定一些时间东西啊。

![](img/f6e5d8b280755015a548f5291e1fd5ed_52.png)

然后第一步你去啊，你可以这样，你可以把保存路径自己写好啊。

![](img/f6e5d8b280755015a548f5291e1fd5ed_54.png)

这个我不说了，这里啊这个early stop，这个意思就是当我们在训练网络过程当中啊，呃如果说是不是大家经常遇到一件事，就是网络训练训练啊，基本上就饱和了，没什么太大的一个变化了。

比如说咱说这个loss吧，loss训练训练过程当中就平了，基本上没什么变化了，可能啊就是这是个1万次，然后你指定个10万次，1万次和10万次结果都没啥差距，那你是不是可以提前进行停止啊。

在这里啊我们可以定义一个监视的功能啊。

![](img/f6e5d8b280755015a548f5291e1fd5ed_56.png)

就是early stopping啊，你把它指定出来，Early stopping，我们看一下在哪导进来的。



![](img/f6e5d8b280755015a548f5291e1fd5ed_58.png)

在这里call bs当中啊，你可以把early stopping，还有checkpoint都导进来。

![](img/f6e5d8b280755015a548f5291e1fd5ed_60.png)

这个类扫表，就像我刚才说的，它会进行一个提前停止，首先啊它你会需要指定一个东西监视哪个指标，如果说你的一个validation loss值，连续两次它都没有进行下降，那是不是就可以停了。

这里啊这个值反正到时候大家自己来指定吧，建议大家就是如果说任务比较难的情况下，指定啊稍微大点的一个值，看看他呀，就是随着迭代过程当中哎，连着多少次他连都提升都没提升，那就暂时要把它停下来。

就是让它结束掉，这就可以了，这个就相当于就是观察哪个指标，你要监测的一个量。

![](img/f6e5d8b280755015a548f5291e1fd5ed_62.png)

下面呢这个checkpoint是这个意思啊，就是它会每一个epoch，都进行一个模型的一个保存，然后呢在这里当你指定一个save best only，它只会保存啊最好的那一次的。

然后这个还是啊它对比的一个指标，我们都是啊用这个validation loss，来去当做一个衡量的，这个反正就是到时候大家自己写一个策略吧，如果说你觉着你学网络比较浪，比较花费时间比较多。

或者说当你用一些脚本去做的时候，你用脚本去做，经常要写大量的实验吧，就是可能你人走了，然后服务器在那还要去跑东西，你脚本都写好了，然后让他尝试各种各样的东西去做，这个时候类似刀片就比较有用了。

能让你更快的去得到更多的一些实验的结果。

![](img/f6e5d8b280755015a548f5291e1fd5ed_64.png)

然后呢这个trap point也也是一样的，这个道理，接下来就是用我的model去fit一下。

![](img/f6e5d8b280755015a548f5291e1fd5ed_66.png)

这就完事了，feat当中，你看x y epoch by size，然后呢把我们刚才这个call back x再指行回去，这就完事了，这样啊咱就完成什么，这样咱就完成了，所我有的操作了。



![](img/f6e5d8b280755015a548f5291e1fd5ed_68.png)

这一块我就没法没法再给大家debug了，只能去给他看得掉了，因为此时要进行训练了。

![](img/f6e5d8b280755015a548f5291e1fd5ed_70.png)

debug模式下要进行训练，是非常非常慢的一个工作，所以说咱们也不在这里debug里边，给大家看的训练了，直接通过整体给大家来run一下，这一步执行完之后，是不是相当于啊。

我们训练完就是得到了一个训练结果了。

![](img/f6e5d8b280755015a548f5291e1fd5ed_72.png)

咱先给大家从头到尾的去执行一下，然后这个model就给大家说到这行，然在这里我们来看执行完这个model春之后，它会执行一个test操作，然后test操作完之后。



![](img/f6e5d8b280755015a548f5291e1fd5ed_74.png)

它还有一个去预测展示的一个结果，这样一会儿咱说这个测试。

![](img/f6e5d8b280755015a548f5291e1fd5ed_76.png)

还有预测展示这个东西，呃，我先从整体上跟大家来看一下，它运行时候的一个效果。

![](img/f6e5d8b280755015a548f5291e1fd5ed_78.png)

在这里，首先啊他已经开始运行了，你看这个因为这个数据比较简单。

![](img/f6e5d8b280755015a548f5291e1fd5ed_80.png)

所以说速度还是挺快的，loss下降还是挺快的，基本上很快啊。

![](img/f6e5d8b280755015a548f5291e1fd5ed_82.png)

就能达到一个非常低的一个loss，因为这个正弦函数啊学起来还是比较容易的。

![](img/f6e5d8b280755015a548f5291e1fd5ed_84.png)

就得到一个比较好的一个结果，你看这个lost现在已经是非常非常小了。

![](img/f6e5d8b280755015a548f5291e1fd5ed_86.png)

行大概两个epoch很快就结束了，结束完之后啊，它会执行一个什么操作，哎顺便给大家看一眼吧，它会执行一个测试操作，在这里我给大家看一下吧，他测试完它的一个结果，然后再跟大家去debug。

看一下他是怎么进行测试的，额还没出来，这个测试比较慢啊。

![](img/f6e5d8b280755015a548f5291e1fd5ed_88.png)

因为测试里边他画图操作是比较多的，这个是他测试的一个结果呃，因为就是它不同啊，不同的一个颜色线，你看这里有不同颜色线吧，不同的颜色线，就相当于它的一个起始位置是不同的。

然后呢这个蓝色的可能这里线条太多了，这个用颜色太多，可能看不出来了，这么的吧，大家就看它的一个整体吻合的一个趋势吧，从它整体本科的一个趋势来看，是不是大致还是一样的，所以说啊。

咱的时间序列基本上在这个正弦问题上，预测起来，是不是非常轻松就能把这个东西做出来啊，然后这么的再给大家看一下呃，我把这个东西一会打上个断点，再来看一下我们的一个预测函数当中啊。



![](img/f6e5d8b280755015a548f5291e1fd5ed_90.png)

他都是怎么去做的。

![](img/f6e5d8b280755015a548f5291e1fd5ed_92.png)