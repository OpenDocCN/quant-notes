# 吹爆！这可能是B站最完整的（Python＋机器学习＋量化交易）实战教程了，花3小时就能从入门到精通，看完不信你还学不到东西！ - P3：第03节-Python for Finance 常用packages 学习 II - 凡人修AI - BV1Yx4y1E7LG

今天我们第三节课上的主要内容分三块，第一个呢是统计分析最优化的数据库塞派，那么里面包括最优化统计检验，差值和数值积分，包括一些解方程等，那第二块呢主要是介绍统计模型的数据库。

那么最常用并且是最大很完整的一个包，叫stats model，那里面主要包括回归和广义的线性模型，还有时间序列分析，TSA的package，包括统计检验和分布拟合，第三块呢主要是一些简单的金融数据处理。

当然这一块在我们之后上课的时候，一旦遇到了一些实际的金融数据操作，还会具体的介绍，那么这里主要是一个大方向的，包括数据的频率如何从啊bomber，雅虎finance qudo等等得到原数据。

还有一些数据的检查清理，包括啊smooth平缓，还有一些季节性的一些data进行调整，包括如何的feel for wor和缺失值的处理。



![](img/fe5b6ec0f2faa85f014aad37daea36de_1.png)

那首先先让我们来看一下status model，就是统计模型，那第一块我们要讲的是回归regression，那么我们比较建议的是自己写一个regression，的一个呃方法。

那么把stats model自带的regression内嵌，首先呢先要定义Y也就是响应变量，你要使用的是data的哪一个color，那嗯这个data呢是以data frame嗯数据形式储存的。

那么code叫Y2，那X呢也就是你的REGREER，那regression呢，可以是好几个数据列的名字的一个list，那x intercept等于一的意思，就是我回归的时候需要考虑这个常数项。

也就是截距项，那result调用的就是stats model的一个OS包，就是SM点2S那第一个位置放的是响应变量Y，第二个放的是X，也就是嗯independent arrival那点fit。

那它就会进行一个自动的回归，那我return呢是想看一下这个parameters，也就是回归出来我的那些参数是一个什么样的。



![](img/fe5b6ec0f2faa85f014aad37daea36de_3.png)

结果好，我们首先呢先导入数据，这就是上节课的内容，我们从excel中读取我们的这个google，还有苹果，还有SSPX的啊时间序列，那啊index column呢又称为day。

那she name呢是那个TEERS的新name，首先呢我们先把这个cos就是price，转换成呃一个收益率，Percentage change，那我们把第一行的NA给去掉，那我们想做的呢是。

第一是我们想做一个啊monthly的，就是每一个月的一个regression，因为呢它其实每一个月的，可能会有一些外部因子，导致呢回归的时候一些变量进行了很大的改变，所以首先我们先使用goodbye。

那goodbye呢我们是按照每个月进行一个啊分块，那嗯我们对每个月GOOBY之后之后的呢，点apply，这个regression是我们上面定义好的，这个回归的函数，那么我们的Y呢是google x呢。

是SSPX跟苹果那打印出来的这个数据框，就是每一个月的这个回归模型的一个参数，那么也就是SPX的return乘以的是0。96，加上呢嗯苹果的return乘以0。14，加上这个截距项。

那就是等于我预测的这个谷歌的价格，这是每个月的这个滑动，应该是rolling的一个估计，那嗯我也可以对一整个数据表进行一个回归，那么不用rolling的话，那就是直接点fit，对一整个啊是九个月的。

每个月的data进行嗯，把他们排在一起进行一个回归，那如果想看回归的结果的话。

![](img/fe5b6ec0f2faa85f014aad37daea36de_5.png)

就是点result summary，那么这边会告诉你的啊，ASSQUARE还有调整r square是多少，那你用的模型用的方法包括F统计量，包括这个三值，包括这个差值信息量和贝叶斯信息量。

就ASBIC都是来检验这个回归的好坏的，那么下面呢会有这个回归的参数，包括参数的参数本身的误差，包括它的P值，那么通过这边的P值是可以看出，P值都比0。05来得高，也就是说基本上是不显著的。

也就是说它几乎等于零，也就意味着这个回归其实并没有什么意义，因为它的相关性非常的弱，那做预测的话呢，就是首先你先定义的是这个X的值，就是向前一步预测X现在当前值是多少。

把它放到这个predict这个函数中。

![](img/fe5b6ec0f2faa85f014aad37daea36de_7.png)

那他就会告诉你，现在你基于上面的模型，你Y预测出来的值是多少，那么跟这个回归相关的就是嗯一个是线性回归，O l s，那就是Y等于X贝塔加个em snow，那这个呃这个误差项呢其实满足一个正态分布。

那么如果是最正常的最小二乘的线性回归，那么这些误差之间是不相关的，那进一步呢就是WLS是一个wait，Weighted the square，那么我们认为的是这些误差项它是易方差的。

他们他们的方差随时间会变化，但是每一个时间之间，就比如说T1跟T1-1之间的，这个误差又是不相关的，所以这个INSAL它是一个对角阵，那如果是GLS的话，叫generalized，那这个时候呢。

这个嗯协方差阵就是一个随意的coverse matrix，也就是它时间之间都会存在着自相关性，那么这个大概就是线性回归的一个初步介绍，那么在之后的应用中呢会有一些深入的。



![](img/fe5b6ec0f2faa85f014aad37daea36de_9.png)

接下来呢让我们来看一下一个关于WEIT，this qu就是权重最小而成的一个应用的例子，首先我们先构造一个虚拟的WARRIO，那么嗯W呢是对于不同的残差项，而有的不同的呃权重，那么我们的一开始的一方差。

方差是一，那么后面的方差呢就设为三，那么我们X是两元的，那么乘以一个贝塔，我们之前设好的啊，前面的变量系数COEFFICI，那么后面呢再乘以一个不同的W，就是我们定义的一方差。

那么再乘以这个1if次方是零一的高斯分布，那么首先我们先用常规的最小二乘进行拟合，那么之前也提到过stats model的OS包怎么样调用，那么我们可以发现ASSQUARE是0。85。



![](img/fe5b6ec0f2faa85f014aad37daea36de_11.png)

那么调整的ASSQUARE呢是0。84。

![](img/fe5b6ec0f2faa85f014aad37daea36de_13.png)

那么我们接下来再用有权重的最小二乘，进行拟合，那么在第一个圆跟第二个圆，是和OLS是一样的，那么第三个位置呢要放上我们的weight，就是每一个长差关于不同的point就不不同的点。

是一个多大的一方差的权重，那我们拟合之后发现呢。

![](img/fe5b6ec0f2faa85f014aad37daea36de_15.png)

us square和调整的us square呢都有所提高，说明在异方差的例子下。

![](img/fe5b6ec0f2faa85f014aad37daea36de_17.png)

用带权重的最小二乘优于普通的最小二乘。

![](img/fe5b6ec0f2faa85f014aad37daea36de_19.png)

这里我们再主要简单介绍一下呃，stus model统计检验的一些检验方法。

![](img/fe5b6ec0f2faa85f014aad37daea36de_21.png)

那么嗯关于正态分布的假设检验，我们很重要的一点是，我们假设了长差的序列是不相关的，那么如果相关的话，会引起额就序列之相关的问题，说明我们这个时候的残差。



![](img/fe5b6ec0f2faa85f014aad37daea36de_23.png)

并并不是完全没有信息的，而是携带了一些能够可以通过回归或者是差分。

![](img/fe5b6ec0f2faa85f014aad37daea36de_25.png)

而获得的信息，所以我们如果要用最小二乘，我们必须保证残差是正态，并且不是相关，并且还和前面的X变量是没有相关性的，那么doin western这个方法呢是来检验序列相关。

那嗯JB检验包括omnibus检验，都是检验残差是否正态。

![](img/fe5b6ec0f2faa85f014aad37daea36de_27.png)

那么这两个检这三个提到的检验呢。

![](img/fe5b6ec0f2faa85f014aad37daea36de_29.png)

都在summary中的后面有列出嗯，那关于像skill的检验。

![](img/fe5b6ec0f2faa85f014aad37daea36de_31.png)

包括COOSIS，就是分度和偏度的检验，也是检验残差的正态性的，那那我们知道正态分布的话，skill也就是偏度是零，那么分度呢是三，所以上面的这个可以证明。



![](img/fe5b6ec0f2faa85f014aad37daea36de_33.png)

我们这个长沙其实不是太正太嗯。

![](img/fe5b6ec0f2faa85f014aad37daea36de_35.png)

接下来还有一些比较常用的检验，比如说我们需要检验一方差，就是我们的残差必须满足方差。

![](img/fe5b6ec0f2faa85f014aad37daea36de_37.png)

不要随时间变化，那么这里的这个go fill qut检验，和这个head white检验，是来检验残差是否存在异方差性的。



![](img/fe5b6ec0f2faa85f014aad37daea36de_39.png)

那么这个ego自回归条差条件的异方差检验呢，适用于时间序列模型，当我们首先使用阿玛或者AR或者是ma，模型的时候，我们需要知道我们是否进一步的得使用。



![](img/fe5b6ec0f2faa85f014aad37daea36de_41.png)

Garch model，也就是我们的时间序列并不满足，stationary并不稳定，这个时候我们的长差的方差是随时间变化的，那么当我们通过这个head arch检验，如果满足了残差是有arch效应。

也就是一发差效应，那么我们就要进一步的使用啊，gotch model对我们的时间序列进行进一步的建模，那么我们的线性模型，还假设我们的Y和X的关系是具有线性的，那么如果不满足的话。

说明我们的模型需要进一步的研究，所以这里有一个哈维collier和rainbow，就是彩虹检验是检验我们的模型是否满足线性。



![](img/fe5b6ec0f2faa85f014aad37daea36de_43.png)

那么还有比较常用的检验。

![](img/fe5b6ec0f2faa85f014aad37daea36de_45.png)

比如说像最后这一条variance infection factor，检验是来检验方差膨胀因子的，就是当我们做线性回归的时候，我们有一条假设是我们的XX的每一个，每一列其实是不相关的，那么如果相关的话。

我们的模型就不够稳健呃，当有一个新的X点进入的时候，当这个点跟别的点偏离比较大的情况下，我们的模型就比如说我们一开始的时候，我们估计我们的贝塔12，那么当X变化了一点点，可能从0。5变化到0。6的时候。

那么这把再把它再带入我们的模型进行训练，那这个时候发现贝塔一的答案居然从啊二，比如说变到了100，当然这是一个比较夸张的情况，那么通过这个可以初步的感受到。

如果我们的x variable具有多重共线性了，那我们的模型比较脆弱，当我们用训练集训练好之后，他对于检验集可能就不适用了，那么我们通过这个检验，可以检验我们的我们是否存在多重共线性。

当方差膨胀因子高于某个值，比如说三，比如说十的时候，我们就有理由证明，我们的这个模型是具有多重共线性的，那么我们需要删除一些跟别的变量比较相关的，一些啊，叫做多余的变量。

或者我们得进行一个step white就逐步回归，或者我们得先做一些变量的选择，比如说PCA。

![](img/fe5b6ec0f2faa85f014aad37daea36de_47.png)

比如说因子模型等等，那么这里是这个doin western，就是检验序列相关性的一个例子，那么我们对上面我们的线性回归的长差，进行检验，那statement是说当答案是二的时候，是序列完全无关的。

那么零是正相关，四呢也就是负相关，那么我们的答案是2。02，也就是证明了我们的序列几乎是无关的。

![](img/fe5b6ec0f2faa85f014aad37daea36de_49.png)

说明我们的线性模型满足了这一条的假设。

![](img/fe5b6ec0f2faa85f014aad37daea36de_51.png)

那我们接下来再介绍一下经验分布拟合。

![](img/fe5b6ec0f2faa85f014aad37daea36de_53.png)

那么经验分布拟合得通过调status model distribution，Ux x experience，门口distribution这个来进行，把这个包进行导入。

就是ECDF那么这个调用其实非常简单。

![](img/fe5b6ec0f2faa85f014aad37daea36de_55.png)

就是大写的ECDF，括号里面的是你的样本样本的一个p panda series，或者是array向量都是可以的，那么它会对我们的向量，进行一个经验分布的拟合，那么当我们把上面的结果给画图画出来之后。

就是一个讲道0~1之间的一个cumulative啊，Probability distribution，嗯接下来我们来介绍一下时间序列，首先先介绍一下比较经常用到的一个嗯库函数，叫daytime。

daytime的意思是定义一个时间时间点，比如说我们可以call daytime点now，那么现在输出的就是现在当前的时间，那么我们还可以对两个时间的，这个时间的instance进行减法。

那得到的是时间的差，但要记住这个daytime它本身也是1delta，本身呢也是一个daytime的一个叫做列子。



![](img/fe5b6ec0f2faa85f014aad37daea36de_57.png)

那么还可以点，比如说call delta点days，那就把天数的差可以展现出来。

![](img/fe5b6ec0f2faa85f014aad37daea36de_59.png)

那么还可以call minutes和second，接下来是这个daytime变量，跟这个字符串进行了转换，那么我们可以靠SSTRSTM，就STR括号里面是一个daytime的一个变量。

那么这里显示的呢就是一个字符串，那么当字符串改成时间呢，你只要定义我的这个字符串，是比如说像年年月日进行排序的。



![](img/fe5b6ec0f2faa85f014aad37daea36de_61.png)

那么就可以输出这个嗯daytime的变量，这是一个相互转换的一个过程，那么也可以直接通过pandas的一个to daytime，把字符串系统的转换成一个daytime的。



![](img/fe5b6ec0f2faa85f014aad37daea36de_63.png)

一个一个指数嗯，接下来我们看把它应用到一个数据框中，首先我们建立一个啊一个随机的一个data values，那么我们的index呢就取为data time，那是从呃2000年的1月1号开始。

那么我们的频率呢是。

![](img/fe5b6ec0f2faa85f014aad37daea36de_65.png)

咳一周的，那这个是我们的一个简单的数学框，那我们常用的手段呢，比如说这个时候想考，我想做这个每日的回归，但是我的数据最高的频率是周，那么这个时候我就可以通过RESAMPLE的这个函数，把它从周扩充成日。

那中间的NNA呢可以用fill forward，也可以用我们之前提到的，比如说三天的一个滚动的均值，或者是比如说我们一开始的时候。



![](img/fe5b6ec0f2faa85f014aad37daea36de_67.png)

数据的间隔是一个季度，那么我们可以通过。

![](img/fe5b6ec0f2faa85f014aad37daea36de_69.png)

我们可以通过一个每周的均值进行一个填充，那么当FU可能是A的时候呢，其实就是以年作为我们的频率，那以年作为频率，有时候我们还可以进行一个季度性的填充。



![](img/fe5b6ec0f2faa85f014aad37daea36de_71.png)

那也是quarter干DECEMBER的意思，那就是我们的第一个点是从呃。

![](img/fe5b6ec0f2faa85f014aad37daea36de_73.png)

第四个季度开始的，我们下面介绍一下这个数据框导入呃。

![](img/fe5b6ec0f2faa85f014aad37daea36de_75.png)

时间序列的导入，包括之后的基于这个导入的数据框进行建模，首先像呃之前提到的，我们用我们用这个pandas data reader把数据进行导入。



![](img/fe5b6ec0f2faa85f014aad37daea36de_77.png)

那么我们导入了之后，我们导入了之后，先得先定义我们的symbol，就是我们的ticker，那这个AAPL呢其实就是苹果的意思，那在第二个位置反杀我们的数据源，那这里是框岛。



![](img/fe5b6ec0f2faa85f014aad37daea36de_79.png)

如果用雅虎的话，就放雅虎，那后面就是起始跟终始的时间。

![](img/fe5b6ec0f2faa85f014aad37daea36de_81.png)

这里用点hat呢是想看，就先看到一个前五个的点是长什么样子的。

![](img/fe5b6ec0f2faa85f014aad37daea36de_83.png)

包括我们的行啊列啊，有一个初步的概念。

![](img/fe5b6ec0f2faa85f014aad37daea36de_85.png)

对于我们后面进行啊序列分析，包括column的call是比较有帮助的。

![](img/fe5b6ec0f2faa85f014aad37daea36de_87.png)

那首先呢我们先把clothes，也就是嗯修饰的时候的最后一个时间点，扣的价格给破出来，那这个时候比如说我想分析他嗯，一个季度的均值大概是怎么样的一个走势，那我们就用点rolling这个函数。

65呢就是65天，那点命呢就是这65天取一个滑动的精子，那么这边刚好复帮大家复习一下，这个关于图形的图例如何的进行展示，那这个时候呢这个大家可以发现这个rolling me，也就是滚动的季度的命。

其实不能非常好的捕捉到，我这个序列的一个走势，那有一种改进方法呢是用指数滑动平均，指数滑动平均不一样的地方是嗯，如果是上面的这种平均，我的在这个时间的window中，我们每一个时间点都是用同样的权重的。

这显然是不合理的，因为我们知道当离现在越近的时间点，一定是对现在的预测是最有帮助的，那么离得越远呢，说明的相关性会越来越低，那么值自动滑动平均呢，就是给每一个时间点都assign了不同的权重。

那么离我现在当前时间点越近的权重就越大，那么它的函数呢是直接在数据的series上面，点1WM，那span呢就是我一整个时间跨度有多大，点命呢就是均值，那么大家可以看到指数滑动平均。

就比正常的同样的平均来的。

![](img/fe5b6ec0f2faa85f014aad37daea36de_89.png)

更能跟踪我这个嗯一整个价格的走势，那么这个下面是指数滑动平均的一个理论基础，那么是当天的价格呢，并且是一减去这个一个系数乘以以前的价格，那么当我们进行迭代之后，就得到下面这个指数滑动平均的一个表达式。

大家可以发现，比如说P4，也就是四天前的价格，那么阿尔法一定是在0~1之间，也就是说随着时间的推移，那么呃为以前的时间，以前的价格，它前面的这个系数一定是趋于零的。

那有时候呢可能我看的比如说是每一个季度，这个滚动的一个分位数，当然我们之后要啊，提到的一个叫做啊风险的一个major，有风险测度，有时候会看我这个价格的5%的分位数，也就是在100个点中。

第五小的大概有多大呢，那这个时候呢我们用一个apply function里面的拉姆达，是对于每一个元素，我都取它5%的这个分位数，那么这个呢画出来的就是呃，每一个季度的这个滑动的5%，分位数到底有多大。

也就是说我的价格我有95%的信心，他不会低于我这每一个点，那我们接下来要介绍时间序列的嗯，几个比较常见的模型，那么第一个就是在我对于我的序列是平稳的，假设的情况下的一个阿玛模型，那什么叫做序列式平稳呢。

序列平稳有三大主要假设，第一假设是均值是序列的，均值呢是一个固定的常数，那第二个假设是序列的方差，是一个固定的假呃常数，那么第三个假设是我这个序列的相关性，比如说嗯我现在是T时间。

那么T加S时间跟我这个嗯，T时间的这个相关程度，比如说是RO，那这个时候如果是T1加S，T加S跟T加两倍的S呢，那它们的相关依序数也只也也得是柔，也就是说我训练相关性的roll的。

这个roll的这个数值只跟呢我这个序列之间，这两个时间点之间的gap有关，跟我序列的起始点是没有关系的，那么这三条假设为什么非常重要，因为当我们有一条金融时间序列的时候，我们希望它满足平稳性。

因为这样我们对它的均值，也就是对于金融上，也就是我们的收益率，那么方差呢也就是我们的风险，我们预测这条时间序列，我们有信心，他们的均值和方差都是一个固定值，如果随时间变化的话。

那我们之前建议的模型就没有意义了，那当然对于啊不平稳的，比如说易方差时间序列，那我们也有新的就是更先进的模型，但是传统模型上我们希望它是平稳的，那这里先简要介绍一下这个二码模型。

当然在之后的有专门的一节课，讲时间训练模型的时候会有更深入的认识，这里只是我们大概的先简要介绍一下，给大家一个初步的认识，那么这里呢我们先自己产生一个，a r two的一个模型。

也就是新的时间点呢是等于它呃，前一步的乘以一个系数，那么前两步的乘一个系数，再加上一个噪音项，那么噪音项呢是一个呃一个正态分布，那么它的均值是零，方差呢是一个自定义方差。

是这样的一个自回归的一个时间序列模型，那这个时候如果我想要估计它的系数，我们就调这个SM就是dance model里面的TSA的一个啊，SUBLIBRARY里面的ARA2横竖。

那么里面放上的是values，就是你获得的时间序列。

![](img/fe5b6ec0f2faa85f014aad37daea36de_91.png)

当你点call这个model点fit的时候，你需要定义我这个最大的步长是多少，那上面我们知道a r two，也就是说也就是说它的步长是二，那么因为我们获得一个序列的时候，我们不知道他真实的补偿是多少。

那么我们就定义一个最大能够达到的波长啊，比如说我们假设是五，这个时候回归之后呢，我们想看它预测出来的参数，那我们可以看到它的啊继续项是几乎是零的，那么我们的一阶项呢是几乎是0。8。

那么二阶项呢是几乎是负的。

![](img/fe5b6ec0f2faa85f014aad37daea36de_93.png)

0。4，那跟我们上面的初始定义是基本吻合的，那比如说好巧不巧，我我能判断出它的最大的滞后可能差不多是二，那当我们把这个参数设为二的时候呢，他的估计呢就其实是更接近的，那0。81负的0。39。

那么关于后面我们如何得到一条数据，对它进行分析，来判断我们这个最大的滞后步长是多大呢，我们在专门的时间序列的课程上会提到，那这里先初步的讲一下，我们如何对AR这个模型的阶数进行判断。

当我获得一条时间序列的时候，我可以把它的ex也就是自相关函数啊给画出来，那么我们定义最大的阶数都20，因为再高的阶数额即使是有相关性，那么这个序列本身也是一个就噪音特别大的，就不建议拿来使用。

所以一般最高阶的这个自相关，差不多可能在十之后嗯，十左右就可以了，那好我们画出它的这个正相关函数，我们发现呢，一阶和就一阶跟二阶的时候是二阶之后的，这个相关系数是比较显著的。

那么之后呢就是低于这个显著水平。

![](img/fe5b6ec0f2faa85f014aad37daea36de_95.png)

那我们就有理由认为，我们这个模型在AR项，是可以是用二阶来进行建模的，那么当我们对它进行建模之后呢，我们要考验长差，就是如果我的模型跟我的假设，我的想法是一致的，都是a r two。

那么就说明我们的这个长差，本身应该是一个白噪声，就是不自相关的，所以当我们把它的ex长差的X函数pro出来之后。



![](img/fe5b6ec0f2faa85f014aad37daea36de_97.png)

我们确实发现就只有这个连接，就是自己的这个方差相存在，那么它自己本身呢是序列不相关的，那关于这个AR模型的是上面的这样的一个例子，那如果加上ma项，也就是滑动平均项呢。



![](img/fe5b6ec0f2faa85f014aad37daea36de_99.png)

我们就得调用这个arena model点ma。

![](img/fe5b6ec0f2faa85f014aad37daea36de_101.png)

那么参数呢参数的设置跟AR模型是类似的，那么具体对AAR模型的阶数应该如何判断，我们在之后的课程中会提到。



![](img/fe5b6ec0f2faa85f014aad37daea36de_103.png)

那么这里呢是简要的介绍一下时间训练模型。

![](img/fe5b6ec0f2faa85f014aad37daea36de_105.png)

有什么样的假设检验，比如说我们要检验是否存在部分子相关。

![](img/fe5b6ec0f2faa85f014aad37daea36de_107.png)

是否存在序列指相关是否存在呢，交叉的斜斜方差是否有互相关函数，包括这个单位根检验，就单位根检验呢，也是基于我们检验序列是否依旧存在着相关性，那么呢这个KPSSS呢是检验啊序列的stationary。

也就是平稳性嗯，linge box q统计量呢也是比较常用的，检验自相关的嗯。

![](img/fe5b6ec0f2faa85f014aad37daea36de_109.png)

包括这个LEVISON作品的递归嗯。

![](img/fe5b6ec0f2faa85f014aad37daea36de_111.png)

那么在呃之后的时间序列，具体课上我们会涉及，这里面主要比较常用的检验方法，那时间序列还有一块比较重要的是，后面会提到的卡尔曼滤波，卡尔曼滤波在呃系统交易中也非常的常用，因为它是一个自学习性的一个序列。

的一个变量衍生过程，所以它比像回归，像普通的时间序列模型来得更智能性，那我们这里先简要的把它的调用，包括这个层次函数展现一下。



![](img/fe5b6ec0f2faa85f014aad37daea36de_113.png)

那我们之后会具体的讨论卡尔曼滤波，毕竟也会有卡尔曼滤波的实例。

![](img/fe5b6ec0f2faa85f014aad37daea36de_115.png)

的分析和实盘操作。

![](img/fe5b6ec0f2faa85f014aad37daea36de_117.png)

接下来我们要介绍一下塞派这个数据库的使用，那么塞派呢主要是一些数学的包，比如说数学分布最优化差值啊，解方程，包括一些凸优化的最求最大值或是最小值，那么首先让我们先来介绍一下差值。

那么差值呢我们是import cpi interpolate这个包，那我们首先先定义一个函数。

![](img/fe5b6ec0f2faa85f014aad37daea36de_119.png)

那它是sin x加上0。5倍的X，这样的一个函数，那么我们要对它进行已知点的差值，首先这个s p l read嗯，差值的第一步的函数，那么第一个位置放的是我的X。

第二个位置呢是FX也就是对应的真实的函数值，那么K等于一呢是定义我们差值函数的阶数，那么K等于一就是线性差值，那我们把差值之后得到的IPO这个结果呢，放到SPOEV这个函数中，那么第一个位置依旧算是X。

第二个位置呢释放上一步的结果，那么得到的IY呢也就是差值点，那我们下，接下来把我们的真实函数和我们的差值点，进行绘图，那么好像这个大体的上来看，我们这个线性差值非常的完美。

但当我们放大某一个嗯函数区域段的时候，其实就不尽然了，那么我们用一样的函数FX，那当我们的XD也就是X的范围，把它缩小到一三之间嗯，缺50个点的时候，我们调用一样的函数，大家就可以发现。

线性函数在没有办法很好的拟合，一个曲线的曲率，那么这个时候呢我们可以考虑用更高的结束，像这边K如果取二呢，就是一个二次差值，那K取三呢就是我们很常用的cube fly，就是三维的立方差值。

那这个时候大家可以发现，三维立方差值能够非常好的拟合，我们的这一条啊，类似抛物线的一个曲率，那接下来要简单介绍一下的是凸优化，那么最优化呢在包括嗯一整个金融建模中，是至关重要的。

我们经常需要遇到一些解方程，或者是最优化的一些问题，那么我们是通过调用CPI点optimize这个包，首先一样的，我们先定义一个，我们需要最优化的一个目标函数。



![](img/fe5b6ec0f2faa85f014aad37daea36de_121.png)

那么我们使用的是boot这个方法，那么第一个位置输入的是我们的函数，那么第二个位置呢，是我们在这里有X跟Y两个变量，那也就是两个变量的考虑的区域，包括我们这个变量能够接受多少个点，那我们前面的命令呢。

嗯当output等于true的意思，就是我们把我们最优化的步骤给打印下来，那他输出的是一个最优化的结果，也就是当X取零，Y取零的时候，我们这个函数达到最小值，当然上面的这个步长是五，那显然是比较粗糙的。

这个时候呢，当我们细化我们的步长取为0。1的时候，这个时候呢自由化的结果呢就变成了负的，1。4和1。4，那当然我们还有别的最优化的方法，那除了这个很常用的BT以外呢。

还有f min就是five minum的意思，那么第一个位置呢依旧是我的函数，那么第二个位置是一个起始点，我们可以用上面的局部最优化的opt one，作为我们的起始值。

那么x toe跟app toe的意思就是，当你找到的前一个点跟下一个点的区别，就是absolute的difference，小鱼嗯，1‰的时候，那么我的迭代就停止了，那让我们来看一下这个最优化的过程。

咳但是呢我们这边收到一个warning，往你的意思就是，我们已经达到了最高的迭代的次数，但是我们依旧没有找到一个全局最优，那这个时候找到的在这些点里面的局部，最优呢是负的1。427。



![](img/fe5b6ec0f2faa85f014aad37daea36de_123.png)

那用更好的一个解决方法，就是我们要选好一个初始值，那么嗯之前的初始值是一个限制，在一个比较小的一个点中，那么找到的是-1。4左右的值，那这个时候呢如果我找2。0，比如说进行一个尝试啊，我们找2。02。

0的这个点，那么我们最多的迭代次数是250次，那么这个时候呢给出的信息就是，我我们的最优化是已经成功了，他总共迭代了46次，那我们找到的一个全局最优的是4。27，也就意味着我们当我们在做最优化的时候。

初始点包括我们自由化的方法的选择，都是非常重要的咳，接下来再介绍一下嗯，最优化嗯，但是呢要加上一些限制条件的，那首先呢不例外，我们先定义一下我们最优化所需要用到的啊。



![](img/fe5b6ec0f2faa85f014aad37daea36de_125.png)

目标函数，我们在定义我们最优化的一个限制，那么我们这里的限制呢是一个不等式，那不等式是一个什嗯，满足一个什么样的方程呢，是我们有S和B两个参数，那么我们满足的是100-10倍的。

X减去十倍的B呢是大于等于零的，那我们设置这个SMB这两个，最有需要最优化的参数的上下限，都是在0~1000之间，那我们调用的是minimize这个函数，那么第一个位置依旧放的是我们的目标函数。

第二个位置放在初始点，第三个位置是定义我们用什么样的方法，有这个BCGF，不同的自由化的收敛函数，那么豹子呢就是我们定义的嗯，我们需要最优化参数的上下限。

那constrain呢也是上面我们定义的这个约束条件，那下面呢会有我们嗯自优化的一个信息，的一个总结，那么我们最优化之后呢，我们目标函数的最小值，最后的结论是负的9。7，那么这个呢是我们的最优化的参数。

最后的答案是S等于八，那么啊B呢就是几乎等于二。

![](img/fe5b6ec0f2faa85f014aad37daea36de_127.png)

那，接下来再简单介绍塞拍的，另外一个很重要的函数是积分，那么我们import是塞派点INTEGR的这个函数，那么首先呢依旧定义我们需要积分的目标函数，那么在这里呢是sin x加上X的平方。



![](img/fe5b6ec0f2faa85f014aad37daea36de_129.png)

我们还要定义积分的上下限啊，AB包括我们积分所需要的积分，函数的X的步长，那么我们可以使用呃不同的数值积分的函数，比如说这个fix quad，比如说QUT，比如说ROBERT。

那么大家可以发现积分的结果嗯是非常类似的。

![](img/fe5b6ec0f2faa85f014aad37daea36de_131.png)

那我们接下来来介绍一下塞派关于分布的模拟，那么我们调用的是塞派点stats，那这里我们的例子呢是BINOMIO的，也就是二项分布的一个拟合，那么这里首先呢我们要定这个BIANOMIO的。

等到MIO的参数，那么第一个呢是N也就是啊到底有多少个ball，那么P呢就是概率，这是我做这个二次实验，那么我们比如说抛硬币翻得正面的概率是多少，那么这里呢嗯首先先定义好X啊，是这个PDF0。1和0。

99，也就是我们X的啊范围的上下限，那么Y呢就是调用白now没有点PMF，嗯把我们之前说好的定义的参量啊放到上面，第一个位置呢是X，第二个位置是有多少个数，我第三个位置呢是概率。

这里呢再简要的复习一下这个关于plot的，比如说像label，label就是名称，那么这边定义的是本道苗PMF，那么这个就是一个二项分布啊，离散的这个。

嗯probability的一个function的一个绘制，嗯那么这里下面呢是一个连续过程的一个例子，那么我们import是多维的正态分布，然后我们这里展现先展现一维，那额跟离散的是一样的。

我们先定义我们的X也是横轴，那么呢Y呢是然后连续的高斯分布的PDF，那第一个位置放X，第二个位置放的是均值，我们假设均值是2。5，第三个位置放的呢是嗯协方差正，那么这里因为是一维的。

其实斜方差正也就是我们的方差，那么假设是0。5，那这个呢就是一个嗯方差是0。5，均值是2。5的一个一维的高斯分布的PDF，那么接下来呢我们简要的介绍一下，CPSTATS里面的一些我们比较常用的统计量。

那么第一个呢是describe，也就是会嗯输出一个数字框，里面有常见的描述统计量，比如说均值啊，方差呀，嗯五个的分分位数就最小最大25，50和75。

那么这个CYTOSIS跟COTESTATES和skill and skill test，也就是介绍数据集的分度和偏度，那么对于啊这个数据是否是正太，有一个或者是肥尾，或者后尾有一个比较好的认识。

嗯还有检测这个样本是否是正太的一个统计量。

![](img/fe5b6ec0f2faa85f014aad37daea36de_133.png)

那接下来的第三块。

![](img/fe5b6ec0f2faa85f014aad37daea36de_135.png)

我们会简要的介绍一下金融数据的处理，其实这一块呢。

![](img/fe5b6ec0f2faa85f014aad37daea36de_137.png)

我们在之前已经或多或少的在讲数据框，包括stats model的时候已经涉及到了，那么这里呢嗯我们会有一个更为宏观的。



![](img/fe5b6ec0f2faa85f014aad37daea36de_139.png)

high level的一个认识，首先我们先介绍一下数据的频率。

![](img/fe5b6ec0f2faa85f014aad37daea36de_141.png)

数据的频率呢是我们设计算法，交易时非常需要考虑的一个因素，因为呢交易系统，当我们take不同的数据频率的时候，对于交易系统的效率要求是完全不一样的，它会影响每一个数据储存的设计啊。

包括回溯测试算法和执行算法，所以更高的频率呢，策略会导致我们需要用到更强大的统计分析，更多的数据点会被应用，所以对我们的处理器有着更高的要求，那么对于哈frequency的策略呢。

我们经常需要花费大量的时间跟精力，来开发它的软件，包括我们要有最好的数据框架，我们有最好的包括排序和order book的插入和删除，包括换序的一个算法，还有就是我们的嗯处理器，跟这个交易所之间的连接。

我们需要最高的速度等等，那么较低的策略频率呢就更容易开发和部署，而且需要的是更少一点的自动化，当然它产生的交易包括收益率啊，包括嗯，包括我们获得这个效益的这个时间跨度。



![](img/fe5b6ec0f2faa85f014aad37daea36de_143.png)

往往都会列于高频交易，那么有主要的三种的数据频率类型，那么第一种呢是比较常见的，像每周和每月的数据，那么甚至呢还有每个季度，都是每个quarter的数据，那么这种数据主要是比较类似于宏光数据，像CPI。

像h pi就是消费指数，还有house的指数，包括GDP，国民生产总值等等，那么这种数据呢他们都是以季度为主的，所以啊周数据，月数据和季度数据，主要是宏观方面的数据和宏观建模。



![](img/fe5b6ec0f2faa85f014aad37daea36de_145.png)

那么每日数据呢大部分是一些retail，就是零售算法，那么我们经常会用到的一个专有名词是end of date，就是每天交易结束的时候，它的价格是多少，那么这个呢就是中低频交易。

或者是啊我们经常使用到的，相对于一些普通的嗯股票行情啊啊债券行情啊，期权啊，期货啊行情啊等等，那么对于end of day，也就是每天只有一个数据，所以我们也并不需要太大的储存需求。

我们一般的模型就是基于，比如说啊一年的模型数据，我们来预测这个下一个季度应该是一个。

![](img/fe5b6ec0f2faa85f014aad37daea36de_147.png)

什么样的performance，那第三类呢就是intro day，也就是日间数据，那么日间数据呢会有很高的频率，是有可能是每小时啊，每5分钟一分钟或者甚至是每秒的数据。

那么叫做就是open high load这个bar，那么像这个框扣的跟这个ta nto feed等等，都会以付费的形式提供我们这种intro day data。

也就是说我们提到的像从yo finance。

![](img/fe5b6ec0f2faa85f014aad37daea36de_149.png)

Google finance kindle，我们能够获得的数据频率最高的其实就是daily，也就是每日数据，所以像映射类的数据比较贵，而且我们要要为它开辟很大的存储空间。

并且嗯其实在比如说很多很多的产品，可能几秒钟或者是几分钟之内。

![](img/fe5b6ec0f2faa85f014aad37daea36de_151.png)

他们都没有交易，所以就会有很多缺失栏，那就需要用到pandas填充，或者是一些更高更high level的一些填充啊。



![](img/fe5b6ec0f2faa85f014aad37daea36de_153.png)

那么接下来介绍一下顺序读取，我们就分为两种类型，第一种是频率比较低的。

![](img/fe5b6ec0f2faa85f014aad37daea36de_155.png)

像每周每月嗯，包括这个日间数据。

![](img/fe5b6ec0f2faa85f014aad37daea36de_157.png)

那么就用我们上面介绍到这个panda data a reader，我们我们知道他的新包name，那么我们就在在第二个位置，需要填入的是他是来自哪个来源，比如说坤的，比如说亚红finance等等。



![](img/fe5b6ec0f2faa85f014aad37daea36de_159.png)

那么第二种呢基于一些频率比较高的教育，我们会与boomer连接，那我们要用到的是这个t i a boomer的这个API，那它的调用也非常的直接，就第一个是建立这样的一个instance。

那就DM点BBG的data manager，那么第二个呢就是我们需要什么ticker，比如说MICROSOFTIBM跟COSTCO，然后呢是u s equity的，那这个的话。

bomber会给客户提供每一个提可的名字，那第三个呢，就是把公布的数据储存到我们本地的data frame，就是数据框中用的是这个get historical。

那么第一个位置呢就是这个last code的price，那第二第三位置，就是我们我们需要的数据的起始点和末点啊。



![](img/fe5b6ec0f2faa85f014aad37daea36de_161.png)

起点跟末点，那当我们把数据破下来之后呢，我们要进行一些简单的处理，比如说第一点我想要这个数据是那个每周的，那我们就在frequency这边设啊week，并且呢是每周中等，那就是干啊。

WEDNESDAY嗯，假设我们把数据aggregate成这样，那么column name，比如说像科罗拉多test，那这个数据呢是比较有可能像周数局，就比较有可能是每个州字的报数GDP这样的数据。

那如果我想把它扩展成daily的，前面也提过很多次了，就是点RESAMPLE。

![](img/fe5b6ec0f2faa85f014aad37daea36de_163.png)

点D就是daily，那B呢就是business day，就是去掉周末的日间数据，那比如说我还想填充分A那就用feel forward，或者也可以fail backwards。

或者也可以fail by mean。

![](img/fe5b6ec0f2faa85f014aad37daea36de_165.png)

那fail by mean呢就是用的apply函数，那么之前也提到过的，那对于金融数据经常需要把它转换成收益率，那就是点percentage change。



![](img/fe5b6ec0f2faa85f014aad37daea36de_167.png)

那第一行是没有数据的，所以在调用一个drop n a。

![](img/fe5b6ec0f2faa85f014aad37daea36de_169.png)

就是如下展现的这样的数据框，那呃金融数据中还往往会遇到一个季节性的，比如说像啊天然气，比如说像扣像梅，那么在冬天的时候，那每年的冬天它的供应量可能都是达到峰值，那夏天的时候很有可能都是相对比较低的。

那么我在进行数据分析的时候，我们比较希望我们的数据是平稳的，也就是之前提到的stationary，所以我们一定要去掉季节性，并且去掉这个trend就是趋势，因为呢带有这个signal的数据。

它一定不是平稳的，所以我们会用到TSA这个包里面的signal，decompose这样的一个函数，那么我们里面放的呢是我们这个数据的series，或者是array，那我们可以把这个结果给pro出来。

我们可以看到他的它的观测值，可以看到它是否有趋势，可以看到它的SYNONALITY的情况，然后也可以看到RECEDUO，那因为我们上面的数据都是我们做出来的，fake data比较平稳的。

所以这里看不出个所以然，当然当我们如果看到他的signal有所表示的时候，比如说我啊从这个图上可以看到SNNT12，也就是一年为一个一次的这个数据循环，那这个时候呢只要对数据进行一个这样的处理。

也就是当前时间减去呢，嗯他在呃前一年或者是前一个季度，只要看我们这个SIDNT的D是多少，那我们进行一个这样的处理呢，就可以去掉它的季节性，那我们获得的数据就是平稳的，更有利于我们之后的建模。



![](img/fe5b6ec0f2faa85f014aad37daea36de_171.png)

那么这就是今天代码主要我们要讲的内容，那今天的作业呢是这样的，就是让大家从框O中提取google苹果，FACEBOOK的这个收盘的价格的时间序列，并且呢把它们合并在一个数据框中。

那我们要求呢它的index是时间，那我们的column也就是列得是他们的名字，那么并且呢我们用谷歌的收益率作为一个回归，那么是基于苹果跟facebook return的一个呃线性回归模型，那我们要求呢。

以05年到10年的数据作为训练集嗯，那么11年的呢就作为预测集，也叫做test集，然后并且呢我们要画出预测的这个return，也就是谷歌的return，预测和他真实情况的一个比较图。

就把它画在一个图形上就好了啊。

![](img/fe5b6ec0f2faa85f014aad37daea36de_173.png)